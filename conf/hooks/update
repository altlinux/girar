#!/bin/sh
#
# An example hook script to mail out commit update information.
# It also blocks tags that aren't annotated.
# Called by git-receive-pack with arguments: refname sha1-old sha1-new
#
# To enable this hook:
# (1) make this file executable by "chmod +x update".
# (2) define the recipient e-mail address in $GIT_DIR/mailto file.
# (3) define the project description in $GIT_DIR/description file.
# (4) optionally define email charset in $GIT_DIR/charset file.
#

LANG=C
LANGUAGE=C
LC_ALL=C
export LANG LANGUAGE LC_ALL

# check ref name
case "$1" in
refs/heads/*)
	ref_style=heads
	ref_name="${1#refs/heads/}"
	;;
refs/tags/*)
	ref_style=tags
	ref_name="${1#refs/tags/}"
	;;
*)
	echo >&2 "*** Unrecognized ref name: $1"
	exit 1
	;;
esac

ref_type="$(git-cat-file -t "$3")" || exit 1

# Only allow annotated tags in a shared repo
case "$1,$ref_type" in
refs/tags/*,tag)
	echo "### Pushing version '$ref_name' to the masses" >&2
	;;
refs/tags/*,*)
	echo >&2 "*** Un-annotated tags are not allowed in this repo"
	echo >&2 "*** Use 'git-tag [ -a | -s ]' for tags you want to propagate."
	exit 1
	;;
esac

diff_max=65536
date_format="%F %T %z"
git_dir="$(readlink -e "$GIT_DIR")" || exit 1
git_dir="${git_dir#/srv/git/pub}"
project_name="${git_dir##*/}"
project_name="${project_name%.git}"
project_type="${git_dir%/*}"
project_type="${project_type##*/}"
project="$project_type/$project_name"
charset="$(head -n1 $GIT_DIR/charset 2>/dev/null)"

check_side_effects()
{
	[ "$project" = "etc/packages" -a "$1" = "refs/heads/master" ]
}

# quote argument for sed regexp.
quote_sed_regexp()
{
	local out="$*"
	if [ -z "${out##*[\[\].^\$\\/]*}" ]; then
		out="$(printf %s "$out" |sed -e 's/[].^$[\/]/\\&/g')" ||
			return 1
	fi
	printf %s "$out"
}

mailto=
find_subscribers()
{
	if [ "$project_type" != packages ]; then
		cat "$GIT_DIR/mailto" 2>/dev/null
		return
	fi

	local s='[[:space:]]'
	local u="$(quote_sed_regexp "${USER#git_}")"
	local p="$(quote_sed_regexp "$project_name")"
	local t="$(quote_sed_regexp "$ref_style")"
	local n="$(quote_sed_regexp "$ref_name")"
	local dir=/etc/giter-email/packages
	local a

	a="$(grep -l "^\\(\\*\\|$u\\)$s\\+\\(\\*\\|$p\\)$s\\+\\(\\*\\|$t\\)$s\\+\\(\\*\\|$n\\)$s*\$" \
		"$dir"/*/subscription |
		sed -ne "s|^$dir/\\([^/]\\+\\)/subscription\$|\\1|p")"
	set -- ${a}
	for a; do
		a="$(quote_sed_regexp "$a")"
		sed -ne "s/^git_$a:[[:space:]]\\+\\([^[:space:]]\\+\\).*/\\1/p" </etc/postfix/git.aliases
	done

	a="$(cat "$dir/$u/distribution" |
		sed -ne "s/^\\(\\*\\|$p\\)$s\\+\\(\\*\\|$t\\)$s\\+\\(\\*\\|$n\\)$s\\+\\([^[:space:]]\\+\\)\$/\\4/p" |
		tr , ' ')"
	set -- ${a}
	for a; do
		a="$(quote_sed_regexp "$a")"
		sed -ne "s/^git_$a:[[:space:]]\\+\\([^[:space:]]\\+\\).*/\\1/p" </etc/postfix/git.aliases
	done
}

mailto="$(
	find_subscribers |
	sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//' |
	sort -u |
	tr -s '\n' , |
	sed -e 's/^,\+//' -e 's/,\+$//'
)"
[ -n "$mailto" ] ||
	check_side_effects "$@" ||
	exit 0

exit_handler()
{
	local rc=$?
	trap - EXIT
	rm -rf -- "$workdir"
	exit $rc
}
workdir="$(mktemp -dt git-update.XXXXXXXX)" || exit 1
trap exit_handler HUP PIPE INT QUIT TERM EXIT

do_side_effects()
{
	check_side_effects "$@" || return
	for n in distribution subscription; do
		if git-diff-tree --name-only "$2" "$3" -- email-"$n" |
		   fgrep -qs email-"$n"; then
			git-cat-file blob "$3:email-$n" 2>/dev/null |
				grep '^[^#]' >"$workdir/$n"
			cp "$workdir/$n" "/etc/giter-email/packages/${USER#git_}/$n"
		fi
	done
}

MSG="$workdir/message"
DIFF="$workdir/diff"

cat >"$MSG" <<EOF
To: $mailto
From: ${USER#git_}@altlinux.org ($(getent passwd "$USER" |cut -d: -f5))
Subject: [git update] $project: ${1#refs/}
Content-Type: text/plain${charset:+; charset=$charset}
X-git-dir: $git_dir
X-git-description: $project

Update of $git_dir

EOF

new_head()
{
	branch="${1#refs/heads/}"
	echo "New branch \`$ref_name' available with the following commits:"
	git-rev-list --pretty "$3" $(git-rev-parse --not --all)
}

new_tag()
{
	# a pushed and annotated tag (usually) means a new version
	tag="${1#refs/tags/}"
	if [ "$ref_type" = tag ]; then
		TAG="$workdir/tag"
		git-cat-file tag "$3" >"$TAG"
		tagger="$(sed -ne '4s/^tagger \([^>]\+>\).*/\1/p' <"$TAG")"
		ts="$(sed -ne '4s/^tagger [^>]\+>[^0-9]*\([0-9]\+\).*/\1/p' <"$TAG")"
		date="$(date --date="1970-01-01 00:00:00 $ts seconds" +"$date_format")"
		echo "Tag '$tag' created by $tagger at $date"
		echo "with the following message:"
		git-cat-file tag "$3" |sed -n '5,$p'
		echo =======
		echo
	fi

	prev="$(git-describe "$3^" 2>/dev/null| sed 's/-g.*//')"
	# the first tag in a repo will yield no $prev
	if [ -z "$prev" ]; then
		echo "Changes since the dawn of time:"
		git-rev-list --pretty "$3"
	else
		echo "Changes since \`$prev':"
		git-diff "$3" "^$prev" >"$DIFF"
		git-diff --stat "$3" "^$prev"
		echo
		git-rev-list --pretty "$3" "^$prev"
		echo
		SIZE="`wc -c $DIFF | sed 's/^[^0-9]*\([0-9]*\).*$/\1/'`"
		if [ $SIZE -ge $diff_max ]; then
			echo "Full changes since \`$prev' are too large ($SIZE bytes)"
		else
			echo "Full changes since \`$prev' follow:"
			cat "$DIFF"
		fi
	fi
}

update_ref()
{
	base="$(git-merge-base "$2" "$3")"
	prev="$(git-describe "$base" 2>/dev/null)" || prev="$base"
	if [ -z "$prev" ]; then
		echo "Changes since the dawn of time:"
		git-rev-list --pretty "$3"
	else
		case "$base" in
		"$2")
			echo "Changes since \`$prev':"
			;;
		*)
			echo "Changes since common ancestor \`$prev':"
			;;
		esac
		git-diff "$3" "^$base" >"$DIFF"
		git-diff --stat "$3" "^$base"
		echo
		git-rev-list --pretty "$3" "^$base"
		echo
		SIZE="`wc -c $DIFF | sed 's/^[^0-9]*\([0-9]*\).*$/\1/'`"
		if [ $SIZE -ge $diff_max ]; then
			echo "Full changes since \`$prev' are too large ($SIZE bytes)"
		else
			echo "Full changes since \`$prev' follow:"
			cat "$DIFF"
		fi
	fi
	do_side_effects "$@"
}

if expr "$2" : '0*$' >/dev/null; then
	# new ref
	case "$1" in
	refs/heads/*)
		new_head "$@"
		;;
	refs/tags/*)
		new_tag "$@"
		;;
	esac
else
	update_ref "$@"
fi >>"$MSG"

if [ -n "$mailto" ]; then
	/usr/sbin/sendmail -i -t <"$MSG"
fi
exit 0
