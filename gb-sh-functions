#!/bin/sh

. gb-sh-conf

oneliner()
{
	printf %s "$*" |tr -s '[:space:]' ' '
}

stamp_echo()
{
	echo "$(LC_TIME=C date '+%Y-%b-%d %T') :: $(oneliner "$*")"
}

gear_nums()
{
	set +f
	cd gears &&
	ls -d [1-9]*/dir 2>/dev/null |cut -d/ -f1 |sort -n
}

src_nums()
{
	set +f
	cd gears &&
	ls -d [1-9]*/dir [1-9]*/srpm 2>/dev/null |cut -d/ -f1 |sort -n
}

package_nums()
{
	set +f
	cd gears &&
	ls -d [1-9]*/package 2>/dev/null |cut -d/ -f1 |sort -n
}

copy_nums()
{
	set +f
	cd gears &&
	ls -d [1-9]*/copy_repo 2>/dev/null |cut -d/ -f1 |sort -n
}

build_nums()
{
	cd build 2>/dev/null || return 0
	set +f
	ls -d [1-9]*/*/{srpm,rpms} 2>/dev/null |cut -d/ -f1 |sort -nu
}

srpm2i()
{
	local f="$1"; shift
	cd build
	set +f
	set -- [1-9]*/*/srpm/"$f"
	set -f
	if ! [ -f "$1" ]; then
		echo " *** cannot find $f in build/*/*/srpm/"
		return 1
	fi >&2
	local IFS=/
	set -- $1
	echo "$1"
}

findrpm()
{
	local dir="$1" f="$2"; shift 2
	set +f
	set -- build/*/*/"$dir"/"$f"
	set -f
	if [ -f "$1" ]; then
		echo "$1"
		return
	else
		echo >&2 " *** cannot find $f in build/*/*/$dir/"
		return 1
	fi
}

findbin()
{
	findrpm rpms "$1"
}

findsrc()
{
	findrpm srpm "$1"
}

_N="%{name}"
_VR="%{version}-%{release}"
_EVR="%|epoch?{%{epoch}:}|$_VR"
_NVR="%{name}-$_VR"
_A="%{arch}"

qsrc()
{
	# src-N  src-EVR  src-F
	find "$@" -name '*.src.rpm' -execdir \
		rpmquery --qf "$_N\t$_EVR\t$_NVR.src.rpm\n" -p -- '{}' '+'
}

qbin()
{
	# bin-N  bin-EVR  bin-A  bin-F  src-F
	find "$@" -name '*.rpm' -not -name '*.src.rpm' -execdir \
		rpmquery --qf "$_N\t$_EVR\t$_A\t$_NVR.$_A.rpm\t%{sourcerpm}\n" -p -- '{}' '+'
}

# Now what's the plan?  I guess we don't just move some files around.
# We deal with "tuples" (src,bin+).  Therefore, the consistent plan is
# to group files into such tuples, and decide how new tuples replace
# the existing tuples.
#
# Thus we have to assume that the repo is consistent: both src->bin+
# and bin->src mappings must exist for every package in the repo.  Stale
# packages cannot be handled by the plan consistently, and removing them
# is someone else's job.
#
# Tuples are represented with the following table:
#
# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-A  bin-F
# -----  -------  -----  -----  -------  -----  -----
#
# Note: the fact that both mappings mentioned above exist roughly means
# that we can join src+bin on %{SOURCERPM}.  This is how we do the table.

mktable()
{
	local x="$1"; shift
	# sort by src-F field
	sort -k3 -o "$x.src"{,}
	sort -k5 -o "$x.bin"{,}
	# join by src-F field
	join -t$'\t' -13 -25 -o '1.1 1.2 1.3 2.1 2.2 2.3 2.4' -- "$x".{src,bin} >"$x"
	sort -u -o "$x"{,}
}

make_repo_table()
{
	local repo="${1-}"
	[ -n "$repo" ] || repo="$GB_REPO_NAME"

	local out="${2:-$repo}"

	if [ -s "$out" ]; then
		return 0
	fi

	local repo_dir
	if [ "$repo" = "$GB_REPO_NAME" ]; then
		repo_dir="$GB_REPO_DIR"
	else
		repo_dir="$(. gb-sh-conf-$repo && printf %s "$GB_REPO_DIR")"
	fi

	if [ -s "$repo_dir/files/list/src.list" ]; then
		sort -u "$repo_dir/files/list/src.list" >"$out.src"
	else
		qsrc "$repo_dir"/{i586,x86_64,noarch}/SRPMS.classic/ >"$out.src"
		sort -u -o "$out.src"{,}
	fi

	if [ -s "$repo_dir/files/list/bin.list" ]; then
		sort -u "$repo_dir/files/list/bin.list" >"$out.bin"
	else
		qbin "$repo_dir"/{i586,x86_64,noarch}/RPMS.classic/ >"$out.bin"
		sort -u -o "$out.bin"{,}
	fi

	mktable "$out"
}

set_GIT_DIR()
{
	local prefix="$1"; shift
	local project="$1"; shift
	local sym="$(printf %s "$project" |cut -c1)"
	GIT_DIR="$prefix/$sym/$project.git"
	export GIT_DIR
}

# When replacing packages, versions must increase.
vercheck()
{
	local EVR1="${1:?}" EVR2="${2:?}"
	# add zero epoch if EVRn does not have epoch
	[ -z "${EVR1##*:*}" ] || EVR1="0:$EVR1"
	[ -z "${EVR2##*:*}" ] || EVR2="0:$EVR2"
	[ "$(rpmevrcmp "$EVR1" "$EVR2")" = -1 ] || return 1
}
