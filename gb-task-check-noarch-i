#!/bin/sh -efu

. gb-sh-tmpdir

i=$1
cd build/$i

rc=0

#
# 1. The same set of noarch packages must be obtained on i586 and x86_64.
#
is_excluded()
{
	local arch="$1"
	if [ -s $arch/excluded -a ! -d $arch/srpm -a ! -d $arch/rpms ]; then
		return 0
	fi
	return 1
}

has_noarch=
for arch in $GB_ARCH; do
	(set +f && cd $arch/rpms && ls *.noarch.rpm) >$tmpdir/$arch.noarch 2>/dev/null
	if [ -s $tmpdir/$arch.noarch ]; then
		has_noarch=1
	fi
done

set -- $GB_ARCH
for arch1 in "$@"; do
	# only check against architectures that follow arch1
	shift
	if [ -z "$has_noarch" ]; then
		continue
	fi
	if is_excluded "$arch1"; then
		echo >&2 "warning ($i): $arch1: non-verifiable noarch packages, due to ExclusiveArch"
		continue
	fi
	for arch2 in "$@"; do
		if is_excluded "$arch2"; then
			# warning already issued
			continue
		fi
		if ! (cd "$tmpdir" && diff -U1 {$arch1,$arch2}.noarch ); then
			echo >&2 "error (#$i): different set of noarch packages"
			rc=1
		fi
	done
done

#
# 2. Noarch packages obtained on i586 and x86_64 must be identical.
#
dump_rpmfile()
{
	rpm -qp --qf '[%{FILENAMES}\t%{FILEMODES:octal}\n]' "$1" >$tmpdir/files
	[ -s $tmpdir/files ] || return 0
	awk -F'\t' '{print"./"$1}' $tmpdir/files |rpmpeek "$1" \
		file -b -f - >$tmpdir/types || [ -s $tmpdir/types ] ||
		{ echo >&2 "${1##*/}: unpack failed"; return 1; }
	sed -i 's/, last modified: [^,]\+//' $tmpdir/types
	sed -i 's/\(PNG image\), [1-9][^,]\+/\1/' $tmpdir/types
	sed -i 's/\(TeX DVI file \)(TeX output .*/\1/' $tmpdir/types
	sed -i 's/broken symbolic link /symbolic link /' $tmpdir/types
	paste $tmpdir/files $tmpdir/types
}

dump_deps()
{
	R='[Requires: %{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]'
	P='[Provides: %{PROVIDENAME} %{PROVIDEFLAGS:depflags} %{PROVIDEVERSION}\n]'
	O='[Obsoletes: %{OBSOLETENAME} %{OBSOLETEFLAGS:depflags} %{OBSOLETEVERSION}\n]'
	C='[Conflicts: %{CONFLICTNAME} %{CONFLICTFLAGS:depflags} %{CONFLICTVERSION}\n]'
	rpmquery --qf "$R$P$O$C" -p "$1"
}

dump_noarch()
{
	dump_rpmfile "$1"
	dump_deps "$1"
}

set -- $GB_ARCH
for arch1 in "$@"; do
	shift
	if [ -z "$has_noarch" ]; then
		continue
	fi
	for arch2 in "$@"; do
		join         $tmpdir/{$arch1,$arch2}.noarch  >$tmpdir/both.noarch
		join -v1 -v2 $tmpdir/{$arch1,$arch2}.noarch >>$tmpdir/only.noarch
		while read -r rpm; do
			dump_noarch $arch1/rpms/"$rpm" >$tmpdir/$rpm.$arch1 </dev/null
			dump_noarch $arch2/rpms/"$rpm" >$tmpdir/$rpm.$arch2 </dev/null
			if ! (cd "$tmpdir" && diff -U1 $rpm.{$arch1,$arch2} ); then
				echo >&2 "error (#$i): non-identical noarch packages"
				rc=1
			fi
		done <$tmpdir/both.noarch
	done
done

#
# 3. /usr/share part of i586 and x86_64 packages should be indentical.
#
find_arch()
{
	(set +f && cd "$1" && ls *.rpm) 2>/dev/null |
	while read -r rpm; do
		case $rpm in
			*.src.rpm | *.noarch.rpm) continue ;;
		esac
		N=$(rpmquery --qf '%{NAME}' -p $1/"$rpm")
		printf '%s\t%s\n' "$N" "$rpm"
	done |
	sort -u
}

has_arch=
for arch in $GB_ARCH; do
	find_arch $arch/rpms >$tmpdir/$arch.arch
	if [ -s $tmpdir/$arch.arch ]; then
		has_arch=1
	fi
done

dump_share()
{
	dump_rpmfile "$1" |
		LC_ALL=C grep '^/usr/share/' || [ $? -eq 1 ]
}

set -- $GB_ARCH
for arch1 in "$@"; do
	shift
	if [ -z "$has_arch" ]; then
		continue
	fi
	for arch2 in "$@"; do
		join         $tmpdir/{$arch1,$arch2}.arch  >$tmpdir/both.arch
		join -v1 -v2 $tmpdir/{$arch1,$arch2}.arch >>$tmpdir/only.arch
		while read -r N rpm1 rpm2; do
			dump_share $arch1/rpms/"$rpm1" >$tmpdir/$rpm1.share </dev/null
			dump_share $arch2/rpms/"$rpm2" >$tmpdir/$rpm2.share </dev/null
			if ! (cd "$tmpdir" && diff -U1 {$rpm1,$rpm2}.share ); then
				echo >&2 "warning (#$i): non-identical /usr/share part"
			fi
		done <$tmpdir/both.arch
	done
done

#
# 4. Identical i586 and x86_64 packages should be noarch.
#
dump_arch()
{
	F='[%{FILENAMES}\t%{FILEMODES:octal}\t%{FILEMD5S}%{FILELINKTOS}\n]'
	rpmquery --qf "$F" -p "$1" |
		LC_ALL=C grep -v '^/usr/share/' || [ $? -eq 1 ]
	dump_deps "$1"
}

srcN=
realArch=
main1=
main2=
fullNoarch=

while read -r N f1 f2; do
	if [ -z "$srcN" ]; then
		srcN=$(rpmquery --qf '%{SOURCERPM}' -p i586/rpms/$f1)
		srcN=${srcN%-*}
		srcN=${srcN%-*}
	fi
	if [ "$N" = "$srcN" ]; then
		main1=$f1
		main2=$f2
		# Toplevel package to be checked later.
		continue
	fi
	dump_arch i586/rpms/$f1   >$tmpdir/$f1.arch
	dump_arch x86_64/rpms/$f2 >$tmpdir/$f2.arch
	if cmp -s $tmpdir/{$f1,$f2}.arch; then
		echo >&2 "warning (#$i): $f1 should be .noarch.rpm"
	else
		realArch=1
	fi
done <$tmpdir/both.arch

if [ -n "$main1$main2" ]; then
	f1=$main1
	f2=$main2
	dump_arch i586/rpms/$f1   >$tmpdir/$f1.arch
	dump_arch x86_64/rpms/$f2 >$tmpdir/$f2.arch
	if cmp -s $tmpdir/{$f1,$f2}.arch; then
		if [ -s $tmpdir/only.arch ] || [ -n "$realArch" ]; then
			# Due to rpm limitations, toplevel package cannot be made noarch.
			:
		else
			echo >&2 "warning (#$i): $f1 should be .noarch.rpm"
			fullNoarch=1
		fi
	else
		realArch=1
	fi
fi

if [ -n "$fullNoarch" ]; then
	# Recheck if the whole package is most good for noarch.
	while read -r N f1 f2; do
		dump_noarch i586/rpms/$f1   >$tmpdir/$f1.noarch
		dump_noarch x86_64/rpms/$f2 >$tmpdir/$f2.noarch
		if cmp -s $tmpdir/{$f1,$f2}.noarch; then
			# Extra check for -m32 packages like cpuburn.
			if sed -n '/^\/usr\/share\//d;/^\//p' $tmpdir/$f2.noarch |
			   grep 'ELF 32-bit .* Intel 80386,'; then
				echo "warning (#$i): $f2 is biarch"
				fullNoarch=
				break
			fi
		else
			fullNoarch=
			break
		fi
	done <$tmpdir/both.arch
	# Force noarch.
	if [ -n "$fullNoarch" ]; then
		echo >&2 "error (#$i): the whole $srcN source package should be made noarch"
		rc=1
	fi
fi

exit $rc
