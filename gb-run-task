#!/bin/sh -efu

trap - HUP INT QUIT PIPE TERM

. gb-sh-functions
. gb-sh-conf

id="$1"; shift

cd "$GB_TASKS_DIR/$id"
enable -f /usr/lib/bash/lockf lockf
# obtain an exclusive lock on the TASKS structure
builtin lockf -v .

seq=$(cat task/seq)
[ -n "$seq" ] && [ "$(($seq%3))" -eq 1 ] ||
	{ echo >&2 "Task $id is not selected for run"; exit 1; }
repo="$(cat task/repo)"

# manual completion
manual=
if [ -f task/manual ]; then
	manual=-s
fi

show_task()
{
	set -- $(set +f; cd gears 2>/dev/null && ls [1-9]*/userid 2>/dev/null |cut -d/ -f1 |sort -n)
	if [ $# -eq 0 ]; then
		echo empty task
		exit 1
	fi
	local i
	for i; do
		printf '#%d ' "$i"
		if [ -s "gears/$i/dir" ]; then
			printf 'build %s from %s' "$(cat "gears/$i/dir")" "$(cat "gears/$i/tag_name")"

		elif [ -s "gears/$i/srpm" ]; then
			printf 'build %s' "$(cat "gears/$i/srpm")"
		elif [ -s "gears/$i/package" ]; then
			local package
			package="$(cat "gears/$i/package")"
			if [ -s "gears/$i/copy_repo" ]; then
				printf 'copy %s from %s' "$package" "$(cat "gears/$i/copy_repo")"
			else
				printf 'delete %s' "$package"
			fi
		else
			printf %s removed
		fi
		echo
	done
}

show_summary()
{
	set -- $(set +f; cd gears 2>/dev/null && ls [1-9]*/userid 2>/dev/null |cut -d/ -f1 |sort -n)
	local i
	for i; do
		if [ -s "gears/$i/dir" ]; then
			local dir tag_name
			dir="$(cat "gears/$i/dir")"
			tag_name="$(cat "gears/$i/tag_name")"
			printf ' %s=%s' "${dir##*/}" "$tag_name"
		elif [ -s "gears/$i/srpm" ]; then
			printf ' srpm=%s' "$(cat "gears/$i/srpm")"
		elif [ -s "gears/$i/package" ]; then
			local action package
			[ -s "gears/$i/copy_repo" ] &&
				action=copy ||
				action=del
			package="$(cat "gears/$i/package")"
			printf ' %s=%s' "$action" "$package"
		fi
	done
}

(
	exec >>task/log 2>&1
	[ -s task/log ] && text=resumed || text=started
	stamp_echo "task #$id for $repo $text:"
	show_task

	# Prepare changes
	set -x
	gb-task-pkgtar
	# Obtain an exclusive lock on the $GB_REPO_DIR.
	# Actually, only shared lock is required for build and checks,
	# but an exclusive lock is required later for commit.
	builtin lockf -v $manual "$GB_REPO_DIR"
	gb-task-build
	gb-task-copy-packages

	# Test changes
	gb-task-check-build
	gb-task-repo-plan
	gb-task-repo-vercheck
	gb-task-repo-unmets
	gb-task-check-acl
	# Obtain an exclusive lock on the $GB_GEARS_DIR.
	# Actually, only shared lock is required for check,
	# but an exclusive lock is required later for commit.
	builtin lockf -v $manual "$GB_GEARS_DIR"
	gb-task-check-girar

	[ -z "$manual" ] ||
		exit 0

	# Apply changes
	gb-task-commit-repo
	gb-task-commit-girar
	gb-task-commit-acl
	gb-task-repo-sync
)

rc=$?
echo "$rc" >task/rc
if [ "$rc" = 0 ]; then
	[ -z "$manual" ] &&
		text=COMPLETE ||
		text=TESTED
else
	text=FAILED
fi
stamp_echo >>task/log "task #$id for $repo $text"

seq=$(cat task/seq)
seq=$(($seq+1))
echo "$seq" >task/seq

[ "$repo" != sisyphus ] ||
	repo=
summary="$(show_summary)"
[ -n "$summary" ] || summary=' empty'

try=$((1+$seq/3))
[ $try -gt 1 ] || try=

mutt -x -c "$GB_REPO_EMAIL" -s "[#$id]${repo:+ $repo} $text${try:+ (try $try)}$summary" -a task/log "git_$(cat task/owner)" </dev/null

exit $rc
