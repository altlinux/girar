#!/bin/sh -efu

[ "$project_type" = etc ] || exit 0

. girar-sh-functions
. shell-mail-address

workdir=
cleanup()
{
	trap - EXIT
	[ -z "$workdir" ] || rm -rf -- "$workdir"
	exit "$@"
}

exit_handler()
{
	cleanup $?
}

signal_handler()
{
	cleanup 143
}

make_workdir()
{
	[ -z "$workdir" ] || return 0
	trap exit_handler EXIT
	trap signal_handler HUP PIPE INT QUIT TERM
	workdir="$(mktemp -dt "$PROG.XXXXXXXX")" || exit 1
}

validate_distribution_subscription()
{
	local where="$1"; shift
	local p="$1"; shift
	local t="$1"; shift
	local n="$1"; shift
	local rest="$1"; shift

	[ -z "$rest" ] ||
		fatal "$where: unexpected field: $rest"

	[ "$p" = '*' ] ||
	printf %s "$p" |egrep -qs "$project_name_regexp" ||
	printf %s "${p%\*}" |egrep -qs "$project_name_regexp" ||
		fatal "$where: invalid package pattern: $p"
	case "$t" in
		\*|head|tag|remote) ;;
		*) fatal "$where: invalid reftype pattern: $t" ;;
	esac
	[ "$n" = '*' ] ||
	git check-ref-format "refs/$n" ||
		fatal "$where: invalid refname pattern: $n"
}

validate_email_list()
{
	local where="$1"; shift
	local addr="$1"; shift
	local a="$(printf %s "$addr" |tr , ' ')"
	set -- ${a}
	for a; do
		if [ -z "${a##*@*}" ]; then
			valid_email "$a" ||
				fatal "$where: invalid email address: $a"
			continue
		fi
		cut -f1 -- "${GIRAR_EMAIL_ALIASES}" |
			fgrep -xqs "${GIRAR_USER_PREFIX}$a:" ||
			fatal "$where: invalid email list: user $a not found."
	done
}

validate_email_distribution()
{
	[ -s "$workdir/distribution" ] || return 0
	local p t n a rest line=0
	while read -r p t n a rest; do
		line="$((1+$line))"
		[ -n "$a" ] ||
			fatal "email-distribution:$line: insufficient fields."
		validate_distribution_subscription \
			"email-distribution:$line" \
			"$p" "$t" "$n" "$rest"
		validate_email_list "email-distribution:$line" "$a"
	done <"$workdir/distribution"
}

validate_email_subscription()
{
	[ -s "$workdir/subscription" ] || return 0
	local u p t n rest line=0
	while read -r u p t n rest; do
		line="$((1+$line))"
		[ -n "$n" ] ||
			fatal "email-subscription:$line: insufficient fields."
		validate_distribution_subscription \
			"email-subscription:$line" \
			"$p" "$t" "$n" "$rest"
		[ "$u" != '*' ] ||
			continue
		printf %s "$u" |egrep -qs "$user_name_regexp" ||
			fatal "$where: invalid user name: $u"
		[ -d "$GIRAR_HOME/$u" ] ||
			fatal "$where: unknown user name: $u"
	done <"$workdir/subscription"
}

validate_acl_groups()
{
	[ -s "$workdir/groups" ] || return 0
	local name rest dups line=0
	while read -r name rest; do
		line="$((1+$line))"
		printf %s "$name" |egrep -qs "$group_name_regexp" ||
			fatal "acl-groups:$line: invalid group name: $name"
		[ "$rest" != '*' ] || continue
		set -- ${rest}
		local u
		for u; do
			printf %s "$u" |egrep -qs "$user_name_regexp" ||
				fatal "acl-groups:$line: invalid user name: $u"
			[ -d "$GIRAR_HOME/$u" ] ||
				fatal "acl-groups:$line: unknown user name: $u"
		done
	done <"$workdir/groups"
	dups="$(sed -n 's/^\([^[:space:]]\+\)[[:space:]].*/\1/p' <"$workdir/groups" |sort |uniq -d)"
	[ -z "$dups" ] ||
		fatal "acl-groups: duplicate groups: $(printf %s "$dups" |tr -s '[:space:]' ' ')"
}

validate_acl_packages()
{
	[ -s "$workdir/packages" ] || return 0
	local name rest dups line=0
	local groups="${GIRAR_ACL_CONF_DIR}/list.groups"
	while read -r name rest; do
		line="$((1+$line))"
		printf %s "$name" |egrep -qs "$project_name_regexp" ||
			fatal "acl-packages:$line: invalid package name: $name"
		[ "$rest" != '*' ] || continue
		set -- ${rest}
		local u
		for u; do
			if [ -z "${u##@*}" ]; then
				[ -n "${u#@}" ] &&
				printf %s "${u#@}" |egrep -qs "$group_name_regexp" ||
					fatal "acl-packages:$line: invalid group name: $u"
				cat "$groups" 2>/dev/null |awk '{print $1}' |grep -qsxe "${u#@}" ||
					fatal "acl-packages:$line: unknown group name: $u"
				continue
			fi
			printf %s "$u" |egrep -qs "$user_name_regexp" ||
				fatal "acl-packages:$line: invalid user name: $u"
			[ -d "$GIRAR_HOME/$u" ] ||
				fatal "acl-packages:$line: unknown user name: $u"
		done
	done <"$workdir/packages"
	dups="$(sed -n 's/^\([^[:space:]]\+\)[[:space:]].*/\1/p' <"$workdir/packages" |sort |uniq -d)"
	[ -z "$dups" ] ||
		fatal "acl-packages: duplicate packages: $(printf %s "$dups" |tr -s '[:space:]' ' ')"
}

check_unsupported_update()
{
	local re="^($1)\$"; shift
	local out
	out="$(git diff-tree --name-only "$arg_oldrev" "$arg_newrev" -- |egrep -v "$re")" ||
		return 0
	fatal "unsupported files: $(printf %s "$out" |tr -s '[:space:]' ' ')"
}

check_update()
{
	local t="$1"; shift
	local n="$1"; shift
	rm -f -- "$workdir/$n"
	git diff-tree --name-only "$arg_oldrev" "$arg_newrev" -- "$t-$n" |
		fgrep -qse "$t-$n" ||
			return 0
	git cat-file blob "$arg_newrev:$t-$n" 2>/dev/null |
		egrep '^[[:space:]]*[^#[:space:]]' |
		cat >"$workdir/$n"
	"validate_${t}_$n"
}

handle_etc_packages()
{
	check_unsupported_update 'acl-groups|acl-packages|email-distribution|email-subscription'
	check_update acl groups "$@"
	check_update acl packages "$@"
	check_update email distribution "$@"
	check_update email subscription "$@"

	for n in groups packages; do
		[ -r "$workdir/$n" ] || continue
		cp "$workdir/$n" "${GIRAR_ACL_STATE_DIR}/$GIRAR_USER/" &&
			message "$n acl configuration updated."
	done

	for n in distribution subscription; do
		[ -r "$workdir/$n" ] || continue
		cp "$workdir/$n" "${GIRAR_EMAIL_DIR}/packages/$GIRAR_USER/" &&
			message "email $n configuration updated."
	done
}

handle_etc_private()
{
	check_unsupported_update 'email-distribution'
	check_update email distribution

	for n in distribution; do
		[ -r "$workdir/$n" ] || continue
		cp "$workdir/$n" "${GIRAR_EMAIL_DIR}/private/$GIRAR_USER/" &&
			message "email $n configuration updated."
	done
}

handle_etc_public()
{
	check_unsupported_update 'email-distribution|email-subscription'
	check_update email distribution
	check_update email subscription

	for n in distribution subscription; do
		[ -r "$workdir/$n" ] || continue
		cp "$workdir/$n" "${GIRAR_EMAIL_DIR}/public/$GIRAR_USER/" &&
			message "email $n configuration updated."
	done
}

case "$project_name" in
	packages|private|public)
		[ "$arg_refname" = 'refs/heads/master' ] ||
			fatal "Unsupported ref name: $arg_refname"
		make_workdir
		"handle_etc_$project_name"
		;;
	*)
		fatal "Unsupported repository: $project"
		;;
esac
