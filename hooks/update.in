#!/bin/sh

LANG=C
LANGUAGE=C
LC_ALL=C
export LANG LANGUAGE LC_ALL

fatal()
{
	printf %s\\n "git-update: $*" >&2
	exit 1
}

if [ "$1" = "refs/heads/origin" ]; then
	fatal "$1 is not designed for publication and therefore is not allowed in this repo"
fi

# check ref name
case "$1" in
refs/heads/*)
	ref_style=head
	ref_name="${1#refs/heads/}"
	;;
refs/tags/*)
	ref_style=tag
	ref_name="${1#refs/tags/}"
	;;
refs/releases/*)
	ref_style=release
	ref_name="${1#refs/releases/}"
	;;
refs/remotes/*)
	ref_style=remote
	ref_name="${1#refs/remotes/}"
	;;
*)
	fatal "Unrecognized ref name: $1"
	;;
esac

ref_type="$(git-cat-file -t "$3")" || exit 1

# Only allow annotated tags and releases in a shared repo
case "$1,$ref_type" in
refs/tags/*,tag|refs/releases/*,tag)
	echo "### Pushing $ref_style \`$ref_name' to the masses" >&2
	;;
refs/tags/*,*|refs/releases/*,*)
	echo >&2 "*** Un-annotated ${ref_style}s are not allowed in this repo"
	echo >&2 "*** Use \`git-tag [ -a | -s ]' for tags you want to propagate."
	exit 1
	;;
esac

diff_max=65536
date_format="%F %T %z"
git_dir="$(readlink -ev "$GIT_DIR")" || exit 1
giter_home="$(readlink -ev "$GITER_HOME")" || exit 1
git_dir="$GITER_HOME${git_dir#$giter_home}"
project_name="${git_dir##*/}"
project_name="${project_name%.git}"
project_type="${git_dir%/*}"
project_type="${project_type##*/}"
project="$project_type/$project_name"
charset="$(head -n1 $GIT_DIR/charset 2>/dev/null)"

check_etc_packages()
{
	[ "$project" = "etc/packages" -a "$1" = "refs/heads/master" ] ||
		return
}

check_packages_releases()
{
	[ "$project_type" = "packages" -a "$ref_style" = "release" ] ||
		return
}

validate_distribution_subscription()
{
	local where="$1" && shift
	local p="$1" && shift
	local t="$1" && shift
	local n="$1" && shift
	local rest="$1" && shift

	if [ -n "$rest" ]; then
		fatal "$where: unexpected field: $rest"
	fi
	[ "$p" = '*' ] ||
		printf %s "$p" |egrep -qs '^[A-Za-z0-9][-A-Za-z0-9_.]+$' ||
		fatal "$where: invalid package pattern: $p"
	case "$t" in
		\*|head|tag|release|remote) ;;
		*) fatal "$where: invalid reftype pattern: $t" ;;
	esac
	[ "$n" = '*' ] ||
		git-check-ref-format "refs/$n" ||
		fatal "$where: invalid refname pattern: $n"
}

validate_email_list()
{
	local where="$1" && shift
	local addr="$1" && shift
	local a="$(printf %s "$addr" |tr , ' ')"
	set -- ${a}
	for a; do
		[ -n "${a##*@*}" ] || continue
		cut -f1 -- "@GITER_EMAIL_ALIASES@" |
			fgrep -xqs "${GITER_USER_PREFIX}$a:" ||
			fatal "$where: invalid email list: user $a not found."
	done
}

handle_etc_packages()
{
	check_etc_packages "$@" || return 0

	local u p t n a line rest
	for n in distribution subscription; do
		if git-diff-tree --name-only "$2" "$3" -- email-"$n" |
		   fgrep -qs email-"$n"; then
			git-cat-file blob "$3:email-$n" 2>/dev/null |
				egrep '^[[:space:]]*[^#]' >"$workdir/$n"
		fi
	done

	if [ -f "$workdir/distribution" ]; then
		line=0
		while read -r p t n a rest; do
			line="$((1+$line))"
			[ -n "$a" ] ||
				fatal "email-distribution:$line: insufficient fields."
			validate_distribution_subscription \
				"email-distribution:$line" \
				"$p" "$t" "$n" "$rest"
			validate_email_list "email-distribution:$line" "$a"
		done <"$workdir/distribution"
	fi

	if [ -f "$workdir/subscription" ]; then
		line=0
		while read -r u p t n rest; do
			line="$((1+$line))"
			[ -n "$n" ] ||
				fatal "email-subscription:$line: insufficient fields."
			validate_distribution_subscription \
				"email-subscription:$line" \
				"$p" "$t" "$n" "$rest"
			[ "$u" = '*' ] ||
				{
					printf %s "$u" |egrep -qs '^[a-z][a-z_0-9]+$' &&
					[ -d "$GITER_HOME/$u" ]
				} ||
				fatal "$where: invalid user pattern: $u"
		done <"$workdir/subscription"
	fi

	for n in distribution subscription; do
		if [ -f "$workdir/$n" ]; then
			cp "$workdir/$n" "@GITER_EMAIL_DIR@/packages/$GITER_USER/"
		fi
	done
}

# Validate that $GITER_USER is release tagger.
validate_release_tagger()
{
	local tagger
	tagger="$(git-cat-file tag "$3" |sed -ne '4s/^tagger [^<]\+<\([^@>]\+\)@.*/\1/p')"

	[ -n "$tagger" ] ||
		fatal "tagger not found"

	[ "$GITER_USER" = "$tagger" ] ||
		fatal "release tagger mismatch: expected $GITER_USER, found $tagger"
}

get_pkgname() {
	local name
	name="$(git-cat-file tag "$3" |
		    sed -ne 's/^Package name:[[:space:]]\+\([^[:space:]]\+\)$/\1/p')"
	[ -n "$name" ] ||
		name="$project_name"
	printf %s\\n "$name"
}

# Global: project_name, ref_name
# Return: 0 if $GITER_USER is allowed to push release tag for $project_name, and 1 otherwise.
check_release_perms()
{
	local releases_file="@GITER_RELEASES@"
	local acldir="@GITER_ACL@"

	# allowed if no non-empty release file available
	[ -s "$releases_file" ] || return 0

	fgrep -xqs "$ref_name" "$releases_file" ||
		fatal "$ref_name: invalid release tag, valid tags are: $(tr '\n' ' '<"$releases_file")"

	# allowed if no acl file available for given ref_name
	[ -s "$acldir/list.packages.$ref_name" ] || return 0

	local aclline builders groups= humans= leader o pkg_name

	pkg_name="$(get_pkgname "$@")"

	# allowed if package is not listed
	aclline="$(grep "^$pkg_name " "$acldir/list.packages.$ref_name")" || return 0

	# aclline format: pkg_name leader builders
	set -- ${aclline}; shift
	leader="$1"; shift
	builders="$*"

	# leader and "*" are allowed
	[ "$GITER_USER" != "$leader" -a "$builders" != "*" ] || return 0

	# expand groups if any
	if [ -z "${builders#*@*}" -a -s "$acldir/list.groups.$ref_name" ]; then
		for o in ${builders}; do
			[ -z "${o%%@*}" ] &&
				groups="$groups|$o" ||
				humans="$humans $o"
		done
		builders="$humans $(sed -r -ne "s/^(${groups#|}) +//p" "$acldir/list.groups.$ref_name")"
	fi
	printf %s "$builders" |grep -qs "\<$GITER_USER\>"
}

handle_packages_releases()
{
	check_packages_releases "$@" || return 0

	validate_release_tagger "$@"

	check_release_perms "$@" ||
		fatal "you have no permission to release this package"

	echo >&2 "sorry, package releases are not handled yet..."
	return 0

	local pkgname geardir commitish

	pkgname="$(get_pkgname "$@")"
	geardir="${git_dir%/.git}"
	commitish="$3"

	[ -n "$GITER_USER" -a -n "$pkgname" -a -n "$geardir" -a -n "$commitish" ] ||
		fatal "unable to get release infomation for package"

	"@CMDDIR@/giter-make-release" "$GITER_USER" "$pkgname" "$geardir" "$commitish"
}

email_new_head()
{
	echo "New $ref_style \`$ref_name' available with the following commits:"
	git-rev-list --pretty "$3" $(git-rev-parse --not --all)
}

email_new_tag()
{
	# a pushed and annotated tag (usually) means a new version
	if [ "$ref_type" = tag ]; then
		local tag="$workdir/tag"
		git-cat-file tag "$3" >"$tag"
		local tagger ts date
		tagger="$(sed -ne '4s/^tagger \([^>]\+>\).*/\1/p' <"$tag")"
		ts="$(sed -ne '4s/^tagger [^>]\+>[^0-9]*\([0-9]\+\).*/\1/p' <"$tag")"
		date="$(date --date="1970-01-01 00:00:00 $ts seconds" +"$date_format")"
		echo "Tag \`$ref_name' created by $tagger at $date"
		echo "with the following message:"
		git-cat-file tag "$3" |sed -n '5,$p'
		echo =======
		echo
	fi

	local prev size
	prev="$(git-describe "$3^" 2>/dev/null| sed 's/-g.*//')"
	# the first tag in a repo will yield no $prev
	if [ -z "$prev" ]; then
		echo "Changes since the dawn of time:"
		git-rev-list --pretty "$3"
	else
		echo "Changes since \`$prev':"
		git-diff -M "$3" "^$prev" >"$DIFF"
		git-diff -M --stat "$3" "^$prev"
		echo
		git-rev-list --pretty "$3" "^$prev"
		echo
		size="`wc -c $DIFF | sed 's/^[^0-9]*\([0-9]*\).*$/\1/'`"
		if [ $size -ge $diff_max ]; then
			echo "Full changes since \`$prev' are too large ($size bytes)"
		else
			echo "Full changes since \`$prev' follow:"
			cat "$DIFF"
		fi
	fi
}

email_update_ref()
{
	local base prev size
	base="$(git-merge-base "$2" "$3")"
	prev="$(git-describe "$base" 2>/dev/null)" || prev="$base"
	if [ -z "$prev" ]; then
		echo "Changes since the dawn of time:"
		git-rev-list --pretty "$3"
	else
		case "$base" in
		"$2")
			echo "Changes since \`$prev':"
			;;
		*)
			echo "Changes since common ancestor \`$prev':"
			;;
		esac
		git-diff -M "$3" "^$base" >"$DIFF"
		git-diff -M --stat "$3" "^$base"
		echo
		git-rev-list --pretty "$3" "^$base"
		echo
		size="`wc -c $DIFF | sed 's/^[^0-9]*\([0-9]*\).*$/\1/'`"
		if [ $size -ge $diff_max ]; then
			echo "Full changes since \`$prev' are too large ($size bytes)"
		else
			echo "Full changes since \`$prev' follow:"
			cat "$DIFF"
		fi
	fi
}

mailto="$(
	"@CMDDIR@/find-subscribers" "$project_name" "$ref_style" "$ref_name" |
	tr -s '\n' , |
	sed -e 's/^,\+//' -e 's/,\+$//' -e 's/,/, /g'
)"
[ -n "$mailto" ] ||
	check_packages_releases "$@" ||
	check_etc_packages "$@" ||
	exit 0

exit_handler()
{
	local rc=$?
	trap - EXIT
	rm -rf -- "$workdir"
	exit $rc
}
workdir="$(mktemp -dt git-update.XXXXXXXX)" || exit 1
trap exit_handler HUP PIPE INT QUIT TERM EXIT

if [ -n "$mailto" ]; then
	DIFF="$workdir/diff"
	MSG="$workdir/message"
	FROM_ADDR="${GITER_USER}@@EMAIL_DOMAIN@ ($(getent passwd "$USER" |cut -d: -f5))"

	cat >"$MSG" <<__EOF
To: $mailto
From: $FROM_ADDR
Reply-To: $FROM_ADDR
Subject: [git update] $project: ${1#refs/}
Content-Type: text/plain${charset:+; charset=$charset}
X-git-dir: $git_dir
X-git-description: $project

Update of $git_dir

__EOF
fi

if expr "$2" : '0*$' >/dev/null; then
	# new ref
	case "$1" in
	refs/heads/*|refs/remotes/*)
		# new head
		[ -z "$mailto" ] ||
			email_new_head "$@" >>"$MSG"
		;;
	refs/releases/*|refs/tags/*)
		# new tag
		handle_packages_releases "$@"
		[ -z "$mailto" ] ||
			email_new_tag "$@" >>"$MSG"
		;;
	esac
else
	# update ref
	handle_etc_packages "$@"
	handle_packages_releases "$@"
	[ -z "$mailto" ] ||
		email_update_ref "$@" >>"$MSG"
fi

[ -z "$mailto" ] ||
	/usr/sbin/sendmail -i -t <"$MSG"
exit 0
