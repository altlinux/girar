#!/bin/sh -efu

. gb-sh-functions
. gb-sh-conf

enable -f /usr/lib/bash/lockf lockf
# obtain an exclusive lock on the $GB_REPO_DIR
builtin lockf -v "$GB_REPO_DIR"

commit()
{
	while read -r N EVR A F; do
		RM $GB_REPO_DIR/$A/RPMS.classic/$F
		RM $GB_REPO_DIR/files/$A/RPMS/$F
	done <plan/rm-bin
	while read -r N EVR A F; do
		bin=$(findbin "$F")
		CP "$bin" $GB_REPO_DIR/files/$A/RPMS/$F
		LN ../../files/$A/RPMS/$F $GB_REPO_DIR/$A/RPMS.classic/$F
	done <plan/add-bin

	while read -r F A; do
		RM $GB_REPO_DIR/$A/SRPMS.classic/$F
	done <plan/rm-srpm2arch
	while read -r N EVR F; do
		RM $GB_REPO_DIR/files/SRPMS/$F
	done <plan/rm-src

	while read -r N EVR F; do
		src=$(findsrc "$F")
		CP "$src" $GB_REPO_DIR/files/SRPMS/$F
	done <plan/add-src
	while read -r F A; do
		LN ../../files/SRPMS/$F $GB_REPO_DIR/$A/SRPMS.classic/$F
	done <plan/add-srpm2arch
}

RM()
{
	if ! [ -f "$1" ]; then
		echo "$1: file not found"
		return 1
	fi >&2
}

CP()
{
	if [ -e "$2" ] || [ -L "$2" ]; then
		echo "$2: file already exists"
		return 1
	fi >&2
}

LN()
{
	if [ -e "$2" ] || [ -L "$2" ]; then
		echo "$2: file already exists"
		return 1
	fi >&2
}

# test commit
commit

sign()
{
	expect - "$@" <<'EOF'
	spawn -noecho rpm --addsign {*}$argv
	expect -exact "Enter pass phrase: "
	send -- "\r"
	expect eof
	set rc [lindex [wait] 3]
	exit $rc
EOF
}

if ! out=$(set +f && sign build/*/*/*/*.rpm); then
	echo "$out"
	echo 'cannot sign rpm packages'
	exit 1
fi >&2

RM()
{
	rm -v "$1"
}

CP()
{
	install -v -p -m644 "$1" "$2"
}

LN()
{
	ln -v -s "$1" "$2"
	if ! [ -f "$2" ]; then
		echo "$2: created dangling symlink"
		rm -v "$2"
		return 1
	fi >&2
}

# real commit
commit

. gb-sh-tmpdir

for arch in i586 x86_64 noarch; do
	genbasedir --topdir=$GB_REPO_DIR --flat --no-oldhashfile --bz2only --mapi $arch classic
	sisyphus_gen_contents $GB_REPO_DIR/$arch/RPMS.classic >$tmpdir/contents_index
	cmp -s $tmpdir/contents_index $GB_REPO_DIR/$arch/base/contents_index ||
		mv -f $tmpdir/contents_index $GB_REPO_DIR/$arch/base/contents_index
done
