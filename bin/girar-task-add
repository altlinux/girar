#!/bin/sh -efu

. girar-sh-functions
PROG='girar-task add'

usage()
{
	[ -z "$*" ] || message "$*"
	echo >&2 "usage: $PROG [<task-id>] <gear-repo> <gear-tag>"
	exit 1
}

if [ "${1-}" = '--help' ]; then
	usage
fi

if [ "$#" -gt 3 ]; then
	usage 'Too many arguments.'
fi
if [ "$#" -lt 2 ]; then
	usage 'Not enough arguments.'
fi

id=
if [ "$#" -eq 3 ]; then
	id=$(girar-task-find-current "$1")
	shift
else
	id=$(girar-task-find-current)
fi

cd "$HOME"

dir0="$1"; shift
dir="${dir0#$PWD/}"
[ "${dir#/}" = "$dir" ] ||
	fatal "$dir0: path to git repository does not belong to allowed directory tree"

dir="$(validate_packages_dir "$dir")"
dir="$(add_git_suffix "$dir")"
[ -d "$dir" ] ||
	fatal "$dir0: directory not available"

[ -z "${dir%%packages/*}" ] ||
	fatal "$dir0: directory should belong to packages/ directory tree"

enable -f /usr/lib/bash/lockf lockf

cd "$dir"
builtin lockf -nv . ||
	fatal "gear repo ${dir##*/} is locked"
dir=$(/bin/pwd)

tag_name="$1"; shift
GIT_DIR=. git rev-parse --symbolic --tags |fgrep -xqse "$tag_name" ||
	fatal "$tag_name: invalid tag name"
tag_id="$(git rev-parse --verify "$tag_name")"
GIT_DIR=. GNUPGHOME=/usr/lib/alt-gpgkeys git verify-tag "$tag_id" ||
	fatal "$tag_name: invalid tag"

cd "$GIRAR_TASKS/$id"
builtin lockf -nv . ||
	fatal "task #$id is locked"

#seq=
#if [ -f task/seq ]; then
#	seq=$(cat task/seq)
#	case "$(($seq%3))" in
#		# awaiting for build
#		0) ;;
#		# work in progress
#		1) fatal "task $id is a work in progress" ;;
#		# have build results
#		2) ;;
#	esac
#fi

gear_nums()
{
	set +f
	cd gears &&
	ls -1 [1-9]*/dir |sort -n |cut -d/ -f1
}

nums=$(gear_nums 2>/dev/null)

check_already_added()
{
	local i a_dir a_tag_name a_tag_id
	for i in $nums; do
		a_dir=$(cat gears/$i/dir)
		a_tag_name=$(cat gears/$i/tag_name)
		a_tag_id=$(cat gears/$i/tag_id)
		if [ "${a_dir##*/}" = "${dir##*/}" ] &&
		   [ "$a_tag_name" = "$tag_name" ]; then
			message "${dir##*/}: tag $tag_name was already added"
			[ "$a_tag_id" = "$tag_id" ] ||
				fatal "${dir##*/}: tag $tag_name has changed"
			exit 0
		fi
		if [ "$a_tag_id" = "$tag_id" ]; then
			# maybe added by another guy
			message "${dir##*/}: tag $tag_name was already added (from $a_dir $a_tag_name)"
			exit 0
		fi
	done
}

check_add_first()
{
	local task_owner
	task_owner=$(cat task/owner)
	[ "$GIRAR_USER" = "$task_owner" ] ||
		fatal "only $task_owner can add 1st gear-repo"
}

if [ -n "$gear_nums" ]; then
	check_already_added
	i=$(echo "$nums" |tail -n1)
else
	check_add_first
	i=0
fi

i=$(($i+1))

atexit()
{
	local rc=$?
	trap - EXIT
	[ "$rc" -eq 0 ] || rm -rf gears/"$i"/
	exit $rc
}

trap '' HUP INT QUIT PIPE TERM
mkdir -p gears
mkdir gears/"$i"
trap atexit EXIT
echo "$dir" >gears/$i/dir
echo "$tag_name" >gears/$i/tag_name
echo "$tag_id" >gears/$i/tag_id

mkdir gears/$i/git
GIT_DIR=gears/$i/git git init -q
GIT_DIR=gears/$i/git git fetch -q "$dir" tag "$tag_name"

echo >&2 "task $id added gear-repo #$i $dir $tag_name"
