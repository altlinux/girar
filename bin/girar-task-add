#!/bin/sh -efu

. girar-sh-functions
. shell-quote
. shell-args

PROG0="$PROG"
PROG='task add'

show_help()
{
	cat <<EOF
$PROG - add a subtask to a task

Usage: $PROG [<task id> [<before subtask id>]] <action> ...

Actions:
  repo <gear repo> <gear tag>
  <gear repo>.git=<gear tag>
  srpm <srpm file>
  <srpm file without suffix>.src.rpm
  del <src package name1> ... <src package nameN>
  rebuild <src package name1> ... <src package nameN>
  copy <src package name> [<from binary repository name>]
  kmodules <kflavour>
  rebuild-unmets
  del-unmets
EOF
	exit
}

show_help_for_action()
{
	case "$action" in
		del-unmets)
			cat <<EOF
$PROG del-unmets - add removals of packages listed in report/unmets-src

report/unmets-src contains the list of src packages corresponding to the list
of unmets generated by the latest task processing that reached the stage of
checking repository unmets.
EOF
			exit
			;;
		rebuild-unmets|remeet)
			cat <<EOF
$PROG rebuild-unmets - add rebuilds of packages listed in report/unmets-src

report/unmets-src contains the list of src packages corresponding to the list
of unmets generated by the latest task processing that reached the stage of
checking repository unmets.
EOF
			exit
			;;
	esac
}

if [ "${1-}" = '--help' ]; then
	show_help
fi

[ "$#" -ge 1 ] || show_usage 'not enough arguments.'

id=
subtask_id=
case "$1" in
	[1-9]*)	id=$(PROG="$PROG" girar-task-find-current "$1"); shift
		case "${1-}" in
			[1-7]*) subtask_id="$1"; shift ;;
		esac ;;
	*)	id=$(PROG="$PROG" girar-task-find-current) ;;
esac

[ "$#" -ge 1 ] || show_usage 'not enough arguments.'

action="$1"; shift

if [ "${1-}" = '--help' ]; then
	show_help_for_action
fi

dir=
gears_i_dir=
validate_repo_dir()
{
	local dir0
	dir0="$dir"
	dir="$(validate_local_exported_gitdir "$dir")"

	local gears_re people_re tasks_re
	gears_re="$GEARS_DIR/[A-Za-z0-9]/$PROJECT_NAME_REGEXP\\.git"
	people_re="$PEOPLE_DIR/$USER_NAME_REGEXP/packages/$PROJECT_NAME_REGEXP\\.git"
	tasks_re="$TASKS_DIR/[1-9][0-9]*/gears/[1-7][0-7]*/git"

	if printf '%s' "$dir" |grep -Exqse "$people_re|$gears_re"; then
		:
	elif printf '%s' "$dir" |grep -Exqse "$tasks_re"; then
		gears_i_dir="$(cat "$dir/../dir")"
	else
		fatal "$dir0: git repository does not belong to allowed directory tree"
	fi

	cd "$dir"
	# obtain a shared lock on the source git repository.
	exec 3<.
	flock -s 3
	dir="$PWD"
}

validate_tag_name()
{
	git rev-parse --symbolic --tags |fgrep -xqse "$tag_name" ||
		fatal "$tag_name: tag name not found"
	tag_id="$(git rev-parse --verify "$tag_name")" ||
		fatal "$tag_name: tag verification failure"
	[ "$tag_name" = "$(git cat-file tag "$tag_id" | sed -n '/^tag /s///p')" ] ||
		fatal "$tag_name: tag name verification failure"
	if ! sig_text="$(git -c gpg.program=girar-gpg verify-tag "$tag_id" 2>&1)"; then
		printf >&2 '%s\n' "$sig_text"
		fatal "$tag_name: tag signature verification failure"
	fi

	fpr="$(printf %s "$sig_text" |
		sed -r '/^gpg:[[:blank:]]+using [^[:blank:]]+ key 0x/!d;s///;q')"
	[ -n "$fpr" ] ||
		fatal "$tag_name: gpg fingerprint not found"

	tag_author="$(girar-gpg --list-keys "$fpr" 2>/dev/null |
		sed '/^uid[[:space:]]\+/!d;s///;q')"
	[ -n "$tag_author" ] ||
		fatal "$tag_name: gpg uid not found"
	# normalize email domain
	local qemail_domain qemail_fqdn
	quote_sed_regexp_variable qemail_domain "${EMAIL_DOMAIN%.*}"
	quote_sed_regexp_variable qemail_fqdn "$EMAIL_DOMAIN"
	tag_author="$(printf %s "$tag_author" |
		LANG=C sed 's/@'"$qemail_domain"'\.[a-z]\+>/@'"$qemail_fqdn"'>/')"

	local userid
	userid="$(printf %s "$tag_author" |
		LANG=C sed -n 's/^[^<]\+<[[:space:]]*\([a-z][a-z0-9_-]\+\)\([[:space:]]*@\|[[:space:]]\+at[[:space:]]\+\).*$/\1/p' |
		tr '[:upper:]' '[:lower:]' |tr - _)"
	[ -n "$userid" ] ||
		fatal "$tag_name: unacceptable signature: login name \`$userid' not found"
}

# side effects: tag_id, tag_name, PWD
validate_gear_rebuild()
{
	local commit_id
	tag_id="$1"; shift
	commit_id="$1"; shift

	cd "$dir"
	# obtain a shared lock on the source git repository.
	exec 3<.
	flock -s 3
	dir="$PWD"

	[ "$(git rev-parse --verify "$tag_id^{commit}")" = "$commit_id" ] ||
		fatal "sid \`gear:$sid' from src index for package \`$package' is out of sync with \`$repo_norm' gears repository"

	tag_name="$(git cat-file tag "$tag_id" | sed -n '/^tag /s///p')"
	GIRAR_GPG_HISTORICAL=yes validate_tag_name
}

# side effects: action, srpm
validate_srpm_rebuild()
{
	local id
	id="$1"; shift

	srpm="$STATE_DIR/repo/$repo_norm/release/latest/files/SRPMS/$srpm_name"
	[ "$(rpmquery --qf '%{sha1header}' -p "$srpm")" = "$id" ] ||
		fatal "sid \`srpm:$sid' from src index for package \`$package' is out of sync with \`$srpm_name' in \`$repo_norm' repository"

	action=srpm-rebuild

	ALT_GPG_KEYS_DIR=/usr/lib/alt-gpgkeys-historical \
		ALT_RPM_KEYS_DIR=/usr/lib/alt-rpmkeys-historical \
		GB_SKIP_POLICYDEPS_CHECK_FOR_SRC_PACKAGES=yes \
		validate_srpm
}

# side effects: repo_norm, srpm_name, dir
validate_rebuild()
{
	local package from_repo src_list evr sym spi sid commit_id
	package="$1"; shift
	from_repo="$1"; shift

	repo_norm="$(girar-normalize-repo-name "$from_repo")"
	src_list="$STATE_DIR/repo/$repo_norm/release/latest/files/list/src.list"
	set -- $(printf %s "$package" | join -o2.2,2.3 - "$src_list")
	[ $# -eq 2 ] ||
		fatal "Invalid request to rebuild a nonexistent package \`$package' from \`$from_repo'"

	evr="$1"; shift
	if [ "$repo" != "$repo_norm" ]; then
		local r_evr
		r_evr="$(GIRAR_ALLOW_SAME_NEVR=1 \
			 girar-check-nevr-in-repo "$package" "$evr" "$repo")" ||
			fatal "package \`$package-$evr' from \`$repo_norm' is not newer than \`$package-$r_evr' in \`$repo'"
	fi
	srpm_name="$1"; shift
	sym="${package:0:1}"
	spi="$STATE_DIR/repo/$repo_norm/index/src/$sym/$package/d-t-s-evr.list"
	set -- $(tail -n1 -- "$spi")
	case $# in
		5) ;;
		4) fatal "src index for package \`$package' in repository \`$from_repo' doesn't contain a source id" ;;
		*) fatal "Repository \`$from_repo' doesn't have a valid src index for package \`$package'" ;;
	esac
	[ "$4" = "$evr" ] ||
		fatal "src index for package \`$package' is out of sync with repository \`$from_repo'"
	sid="$5"

	commit_id=
	dir="$GEARS_DIR/$sym/$package.git"
	if [ -f "$dir/git-daemon-export-ok" ]; then
		commit_id="$(git --git-dir="$dir" rev-parse \
				--branches="[${repo_norm:0:1}]${repo_norm:1}")"
	fi
	nevr="$package	$evr"

	case "$sid" in
		gear:*)
			[ -z "$commit_id" ] || {
				validate_gear_rebuild "${sid#gear:}" "$commit_id"
				return
			}
			;;
		srpm:*)
			[ -n "$commit_id" ] || {
				validate_srpm_rebuild "${sid#srpm:}"
				return
			}
			;;
	esac
	fatal "sid \`$sid' from src index for package \`$package' is out of sync with \`$from_repo' gears repository"
}

nevr=
validate_srpm()
{
	nevr="$(rpmquery -p --qf '%{name}\t%|epoch?{%{epoch}:}|%{version}-%{release}' -- "$srpm")" ||
		fatal "$srpm: rpmquery failed"
	package="${nevr%	*}"
	env GB_REPO_NAME="$repo" PATH="/usr/libexec/girar-builder:$PATH" \
		gb-y-sisyphus_check --files -- "$srpm" ||
			fatal "$srpm: sisyphus_check failed"
}

srpm_tmp_locked=
validate_srpm_build()
{
	[ -n "${srpm##*/*}" -a "$srpm" != "${srpm%.src.rpm}" ] ||
		fatal "$srpm: Invalid path"
	pushd "$INCOMING_DIR/$GIRAR_USER" >/dev/null
	[ -f "$srpm" ] ||
		fatal "$srpm: File not found"

	mkdir -p tmp
	# obtain an exclusive lock on the srpm tmp directory.
	exec 3< tmp
	flock 3
	mv -- "$srpm" tmp/
	cd tmp

	validate_srpm

	local s_evr r_evr
	s_evr="${nevr#*	}"
	r_evr="$(girar-check-nevr-in-repo "$package" "$s_evr" "$repo")" ||
		fatal "$srpm is not newer than $package-$r_evr in \`$repo'"

	sid="$(rpmquery -p --qf 'srpm:%{sha1header}\n' -- "$srpm")" ||
		fatal "$srpm: rpmquery failed"
	girar-check-sid "$package" "$s_evr" "$sid" "$repo" || {
		case "$?" in
			1) fatal "package \`$package' version \`$s_evr' is already built but no source id was recorded" ;;
			2) fatal "package \`$package' version \`$s_evr' is already built from a different source" ;;
		esac
	}

	popd >/dev/null
}

handle_subactions()
{
	local subaction n added=0 rc=0
	subaction="$1"; shift
	for n; do
		girar-task-add "$id" "$subaction" "$n" || {
			rc=1
			break
		}
		added=$((added+1))
	done
	local s=
	[ $added -le 1 ] ||
		s=s
	local of=
	[ $added -eq $# ] ||
		of=" of $#"
	echo >&2 "task #$id: added $added$of $subaction subtask$s"
	exit $rc
}

handle_kmodules()
{
	local kimage qkflavour
	kimage="kernel-image-$kflavour"

	girar-check-package-in-repo "$kimage" "$repo" ||
		fatal "package \`$kimage' not found in \`$repo'"

	cd "$STATE_DIR/repo/$repo/release/latest/files/list"

	quote_sed_regexp_variable qkflavour "$kflavour"
	set -- $(sed -n "s/^\\(kernel-modules-[^[:space:]]\\+-$qkflavour\\)[[:space:]].*/\1/p" src.list)
	[ $# -gt 0 ] ||
		fatal "task #$id: nothing to add for \`$kimage'"

	handle_subactions rebuild "$@"
}

handle_unmets()
{
	local subaction
	subaction="$1"; shift

	[ -s report/unmets-src ] ||
		fatal "task #$id: no unmets to $subaction"

	local self
	self=$(join -o1.1 plan/add-src report/unmets-src)
	[ -z "$self" ] ||
		fatal "task #$id: cannot $subaction unmets: $(printf %s "$self" |tr -s '[:space:]' ' ')"
	set -- $(cat report/unmets-src)
	[ $# -gt 0 ] ||
		fatal "task #$id: no unmets to $subaction"

	handle_subactions "$subaction" "$@"
}

case "$action" in
	repo)
	[ "$#" -eq 2 ] || show_usage 'not enough arguments.'
	dir="$1"; shift
	tag_name="$1"; shift
	;;
	del|rebuild)
	[ "$#" -ge 1 ] || show_usage 'not enough arguments.'
	if [ "$#" -eq 1 ]; then
		package="$1"; shift
	else
		subaction=$action
		action=multi
	fi
	;;
	kmodules)
	[ "$#" -le 1 ] || show_usage 'too many arguments.'
	[ "$#" -ge 1 ] || show_usage 'not enough arguments.'
	[ -z "$subtask_id" ] ||
		show_usage "subtask #$subtask_id is not supported for \`$action' action"
	kflavour="$1"; shift
	;;
	copy)
	[ "$#" -ge 1 ] || show_usage 'not enough arguments.'
	package="$1"; shift
	copy_repo=
	if [ $# -ge 1 ]; then
		copy_repo="$1"; shift
	fi
	[ -n "$copy_repo" ] || copy_repo="${GIRAR_DEFAULT_REPO:-sisyphus}"
	copy_repo="$(girar-normalize-repo-name "$copy_repo")"
	;;
	srpm)
	[ "$#" -le 1 ] || show_usage 'too many arguments.'
	[ "$#" -ge 1 ] || show_usage 'not enough arguments.'
	srpm="$1"; shift
	;;
	del-unmets|rebuild-unmets|remeet)
	[ "$#" -eq 0 ] || show_usage 'too many arguments.'
	;;
	*.git=*)
	[ "$#" -eq 0 ] || show_usage 'too many arguments.'
	dir="${action%%=*}"
	tag_name="${action#*.git=}"
	action=repo
	;;
	*.src.rpm)
	[ "$#" -eq 0 ] || show_usage 'too many arguments.'
	srpm="$action"
	action=srpm
	;;
	*) show_usage "invalid action: $action" ;;
esac

cd "$TASKS_DIR/$id"
if [ "${GIRAR_TASK_LOCKED-}" != "$id" ]; then
	# obtain an exclusive lock on the TASKS structure
	exec <.
	flock -n 0 ||
		fatal "task #$id is locked"
	export GIRAR_TASK_LOCKED="$id"
fi

repo="$(cat task/repo)"
repo_conf="$CONF_DIR/repo/$(girar-normalize-repo-name "$repo")"
if [ -s "$repo_conf" ]; then
	. "$repo_conf"
fi

case "$action" in
	repo)
	validate_repo_dir
	validate_tag_name
	;;
	srpm)
	validate_srpm_build
	;;
	del)
	girar-check-package-in-repo "$package" "$repo" ||
		fatal "Invalid request to delete a nonexistent package \`$package' from \`$repo'"
	;;
	rebuild)
	validate_rebuild "$package" "$repo"
	;;
	multi)
	handle_subactions "$subaction" "$@"
	;;
	kmodules)
	handle_kmodules
	;;
	del-unmets)
	handle_unmets del
	;;
	rebuild-unmets|remeet)
	handle_unmets rebuild
	;;
	copy)
	[ "$repo" != "$copy_repo" ] ||
		fatal "Invalid request to copy package from \`$copy_repo' to \`$repo'"
	[ "$repo" != "${GIRAR_DEFAULT_REPO:-sisyphus}" ] ||
		fatal "Invalid request to copy package to \`$repo'"
	validate_rebuild "$package" "$copy_repo"
	;;
esac
cd "$TASKS_DIR/$id"

check_task_modifiable

nums=$(gear_nums)

check_already_added_repo()
{
	local i
	for i in $nums; do
		[ -s gears/$i/dir ] || continue
		local a_dir a_tag_name a_tag_id
		a_dir=$(cat gears/$i/dir)
		a_tag_name=$(cat gears/$i/tag_name)
		a_tag_id=$(cat gears/$i/tag_id)
		if [ "$a_tag_id" = "$tag_id" ]; then
			# same tag
			fatal "${dir##*/}: this tag $tag_name was already added (subtask #$i, from $a_dir $a_tag_name)"
		fi
		if [ "$a_tag_name" = "$tag_name" ] &&
		   [ "${a_dir##*/}" = "${dir##*/}" ]; then
			# different tags with the same name, from very similar git dirs.
			fatal "${dir##*/}: another tag $tag_name was already added (subtask #$i, from $a_dir)"
		fi
	done
}

check_already_added_package()
{
	local i
	for i in $nums; do
		[ -s gears/$i/package ] || continue
		local a_name reason
		a_name=$(cat gears/$i/package)
		[ "$a_name" = "$package" ] || continue
		if [ -f gears/$i/copy_repo ]; then
			reason="copy from $(cat gears/$i/copy_repo)"
		elif [ -f gears/$i/dir ]; then
			reason="rebuild from $(cat gears/$i/dir) $(cat gears/$i/tag_name)"
		elif [ -f gears/$i/srpm ]; then
			reason="rebuild from $(cat gears/$i/srpm)"
		else
			reason="deletion"
		fi
		fatal "task #$id: package $package was already queued by $(cat gears/$i/userid) for $reason in subtask #$i"
	done
}

check_already_added_srpm()
{
	local i
	for i in $nums; do
		[ -s gears/$i/srpm -a -s gears/$i/nevr ] || continue
		local a_nevr a_name
		a_nevr="$(cat gears/$i/nevr)"
		a_name="${a_nevr%	*}"
		[ "$a_name" = "$package" ] || continue
		fatal "task #$id: package $(cat gears/$i/srpm) was already queued by $(cat gears/$i/userid) for build in subtask #$i"
	done
}

check_already_added()
{
	case "$action" in
		repo)
		check_already_added_repo
		;;
		copy|del|srpm|srpm-rebuild)
		check_already_added_srpm
		check_already_added_package
		;;
		rebuild)
		check_already_added_repo
		check_already_added_srpm
		check_already_added_package
		;;
	esac
}

check_add_first()
{
	[ -z "$subtask_id" ] ||
		fatal "subtask #$subtask_id not found"
	local task_owner
	task_owner=$(cat task/owner)
	[ "$GIRAR_USER" = "$task_owner" ] ||
		fatal "only $task_owner can add first subtask"
}

check_add_nth()
{
	if [ -n "$subtask_id" ]; then
		local i
		for i in $nums; do
			[ "$i" != "$subtask_id" ] || break
		done
		[ "$i" = "$subtask_id" ] ||
			fatal "subtask #$subtask_id not found"
	fi
	[ -w gears ] ||
		fatal 'gears: Permission denied'
}

find_new_subtask_id()
{
	local i
	if [ -z "$subtask_id" ]; then
		i=$(printf %s "$nums" |tail -n1)
		printf %o $((0$i+0100))
		return
	fi
	local prev=
	for i in $nums; do
		[ "$i" != "$subtask_id" ] || break
		prev="$i"
	done
	[ "$i" = "$subtask_id" ] ||
		fatal "subtask #$subtask_id not found"
	[ -n "$prev" ] || prev=0
	i=$(((0$prev+0$subtask_id)/2))
	i=$(printf %o "$i")
	[ "$i" -gt "$prev" -a "$i" -lt "$subtask_id" ] ||
		fatal "no room left before subtask #$subtask_id"
	printf %s $i
}

if [ -n "$nums" ]; then
	check_add_nth
	check_already_added
	i=$(find_new_subtask_id)
else
	check_add_first
	i=100
fi

if [ "$GIRAR_USER" = "$(cat task/owner)" ]; then
	gears_i_mode=3775
else
	gears_i_mode=2775
fi

atexit()
{
	local rc=$?
	trap - EXIT
	[ "$rc" -eq 0 ] || rm -rf gears/"$i"/ acl/approved/"$i"/ acl/disapproved/"$i"/
	exit $rc
}

change_state()
{
	girar-task-change-state "$id" NEW
	girar-hook-event subtask create "$id" "$i"
}

trap '' HUP INT QUIT PIPE TERM
# gears are not shared by default
mkdir -pm2755 gears acl acl/approved acl/disapproved
mkdir -m "$gears_i_mode" gears/"$i" acl/approved/"$i" acl/disapproved/"$i"
trap atexit EXIT

case "$action" in
	del)
	logger -t "$PROG0" "user=$GIRAR_USER task=$id subtask=$i delete package $package from $repo"
	printf '%s\n' "$package" >gears/$i/package
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	change_state
	echo >&2 "task #$id: added #$i: delete package $package from $repo"
	exit 0
	;;
	srpm)
	logger -t "$PROG0" "user=$GIRAR_USER task=$id subtask=$i build srpm $srpm"
	mv -- "$INCOMING_DIR/$GIRAR_USER/tmp/$srpm" gears/$i/
	printf '%s\n' "$srpm" >gears/$i/srpm
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	printf '%s\n' "$nevr" >gears/$i/nevr
	rpmquery --qf 'srpm:%{sha1header}\n' -p gears/$i/"$srpm" >gears/$i/sid
	change_state
	echo >&2 "task #$id: added #$i: build srpm $srpm"
	exit 0
	;;
	srpm-rebuild)
	logger -t "$PROG0" "user=$GIRAR_USER task=$id subtask=$i rebuild srpm $srpm_name"
	install -p -- "$srpm" gears/$i/
	printf '%s\n' "$srpm_name" >gears/$i/srpm
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	printf '%s\n' "$nevr" >gears/$i/nevr
	rpmquery --qf 'srpm:%{sha1header}\n' -p gears/$i/"$srpm_name" >gears/$i/sid
	printf '%s\n' "$repo_norm" >gears/$i/rebuild_from
	printf '%s\n' "$package" >gears/$i/package
	change_state
	echo >&2 "task #$id: added #$i: rebuild srpm $srpm_name"
	exit 0
	;;
esac

logger -t "$PROG0" "user=$GIRAR_USER task=$id subtask=$i build tag \"$tag_name\" from $dir"
[ -n "$gears_i_dir" ] || gears_i_dir="$dir"
printf '%s\n' "$gears_i_dir" >gears/$i/dir
printf '%s\n' "$tag_name" >gears/$i/tag_name
printf '%s\n' "$tag_id" >gears/$i/tag_id
printf '%s\n' "gear:$tag_id" >gears/$i/sid
printf '%s\n' "$tag_author" >gears/$i/tag_author
printf '%s\n' "$GIRAR_USER" >gears/$i/userid
case "$action" in
	copy|rebuild)
		printf '%s\n' "$nevr" >gears/$i/nevr
		printf '%s\n' "$repo_norm" >gears/$i/rebuild_from
		printf '%s\n' "$package" >gears/$i/package
		;;
esac

GIT_DIR=gears/$i/git
export GIT_DIR
mkdir "$GIT_DIR"
git init -q --template=/var/empty
if [ "$action" = rebuild ]; then
	echo "$dir/objects" > "$GIT_DIR"/objects/info/alternates
fi
printf >&2 %s "fetching tag \"$tag_name\" from $dir... "
git fetch -q --recurse-submodules=no "$dir" tag "$tag_name"
echo >&2 done
git branch master "tags/$tag_name"
git tag -l --points-at master |
	while read t; do
		[ "$t" = "$tag_name" ] ||
			git tag -d "$t" > /dev/null
	done
if git cat-file tag "$tag_id" | grep -Eqs '^X-(gear|girar)-specsubst:'; then
	git tag -l | grep -Fxve "$tag_name" |
	while read t; do
		git cat-file tag "$t" |
		   grep -Eqs '^X-(gear|girar)-specsubst:' ||
			   continue
		git tag -d "$t" > /dev/null
	done
fi
git pack-refs --all --prune
find "$GIT_DIR/refs" -mindepth 1 -type d -delete ||:
touch "$GIT_DIR/git-daemon-export-ok"

if [ -O gears ]; then
	# git directories should be writable by builder
	find "$GIT_DIR" -type d -execdir chmod g+w -- '{}' '+'
else
	# directories added to alien task should be writable by task owner
	find "gears/$i" -type d -execdir chmod g+w -- '{}' '+'
fi

pkg_tar="gears/$i/pkg.tar"
printf >&2 %s "generating pkg.tar for ${dir##*/} tag \"$tag_name\"... "
if env TZ=UTC gear ${GEAR_ARGS-} -t "$tag_name" -- "$pkg_tar" &&
   [ -s "$pkg_tar" ]; then
	echo >&2 done
else
	rm -f "$pkg_tar"
	fatal "failed to create pkg.tar for ${dir##*/} tag \"$tag_name\""
fi

change_state
echo >&2 "task #$id: added #$i: build tag \"$tag_name\" from $dir"
