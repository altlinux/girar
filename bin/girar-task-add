#!/bin/sh -efu

. girar-sh-functions
. shell-quote
PROG='girar-task add'

usage()
{
	[ -z "$*" ] || message "$*"
	cat >&2 <<EOF
Usage: $PROG [<task_id>] repo <gear_repo> <gear_tag>
   or: $PROG [<task_id>] srpm <srpm file>
   or: $PROG [<task_id>] del <package>
   or: $PROG [<task_id>] copy <package> [<binary_repository_name>]
EOF
	exit 1
}

if [ "${1-}" = '--help' ]; then
	usage
fi

[ "$#" -le 4 ] || usage 'Too many arguments.'
[ "$#" -ge 2 ] || usage 'Not enough arguments.'

id=
case "$1" in
	[1-9]*)	id=$(PROG="$PROG" girar-task-find-current "$1"); shift ;;
	*)	id=$(PROG="$PROG" girar-task-find-current) ;;
esac

action="$1"; shift

enable -f /usr/lib/bash/lockf lockf

validate_repo_dir()
{
	local dir0="$dir"

	cd
	dir="$(printf %s "$dir" |tr -s /)"
	dir="$(prefix_packages "$dir")"
	dir="$(add_git_suffix "$dir")"
	[ "${dir#/}" != "$dir" ] ||
		dir="$GIRAR_HOME/$GIRAR_USER/$dir"
	[ "${dir#$GIRAR_HOME/}" != "$dir" ] &&
	printf '%s' "$dir" |egrep -qs "^$GIRAR_HOME/"'[a-z][a-z_0-9]+/packages/[A-Za-z0-9][-A-Za-z0-9_.]+[.]git$' ||
		fatal "$dir0: path to git repository does not belong to allowed directory tree"

	[ -d "$dir" ] ||
		fatal "$dir0: directory not available"

	cd "$dir"
	# obtain a shared lock on the source git repository.
	builtin lockf -s -v .
	dir="$PWD"
}

validate_tag_name()
{
	git rev-parse --symbolic --tags |fgrep -xqse "$tag_name" ||
		fatal "$tag_name: tag name not found"
	tag_id="$(git rev-parse --verify "$tag_name")" ||
		fatal "$tag_name: tag verification failure"
	if ! sig_text="$(GNUPGHOME=/usr/lib/alt-gpgkeys git verify-tag "$tag_id" 2>&1)"; then
		printf >&2 '%s\n' "$sig_text"
		fatal "$tag_name: tag signature verification failure"
	fi

	fpr="$(printf %s "$sig_text" |
		sed '/^gpg: Signature made .* using .* key ID */!d;s///;q')"
	[ -n "$fpr" ] ||
		fatal "$tag_name: gpg fingerprint not found"

	tag_author="$(GNUPGHOME=/usr/lib/alt-gpgkeys gpg --list-keys "$fpr" 2>/dev/null |
		sed '/^uid[[:space:]]\+/!d;s///;q')"
	[ -n "$tag_author" ] ||
		fatal "$tag_name: gpg uid not found"
	# normalize email domain
	local qemail_domain qemail_fqdn
	quote_sed_regexp_variable qemail_domain "${EMAIL_DOMAIN%.*}"
	quote_sed_regexp_variable qemail_fqdn "$EMAIL_DOMAIN"
	tag_author="$(printf %s "$tag_author" |
		LANG=C sed 's/@'"$qemail_domain"'\.[a-z]\+>/@'"$qemail_fqdn"'>/')"

	local userid
	userid="$(printf %s "$tag_author" |
		LANG=C sed -n 's/^[^<]\+<[[:space:]]*\([a-z][a-z0-9_-]\+\)\([[:space:]]*@\|[[:space:]]\+at[[:space:]]\+\).*$/\1/p' |
		tr '[:upper:]' '[:lower:]' |tr - _)"
	[ -n "$userid" -a -d "$GIRAR_PEOPLE_QUEUE/$userid" ] ||
		fatal "$tag_name: unacceptable signature: login name \`$userid' not found"
}

srpm_tmp_locked=
validate_srpm()
{
	[ -n "${srpm##*/*}" -a "$srpm" != "${srpm%.src.rpm}" ] ||
		fatal "$srpm: Invalid path"
	pushd "$HOME/incoming" >/dev/null
	[ -f "$srpm" ] ||
		fatal "$srpm: File not found"

	mkdir -p tmp
	if [ -z "$srpm_tmp_locked" ]; then
		# obtain an exclusive lock on the srpm tmp directory.
		builtin lockf -v tmp
		srpm_tmp_locked=1
	fi
	mv -- "$srpm" tmp/
	cd tmp

	package="$(rpmquery -p --qf '%{name}' -- "$srpm")" ||
		fatal "$srpm: rpmquery failed"
	GB_REPO_NAME="$repo" sisyphus_check --files -- "$srpm" ||
		fatal "$srpm: sisyphus_check failed"

	popd >/dev/null
}

case "$action" in
	repo)
	[ "$#" -eq 2 ] || usage 'Not enough arguments.'
	dir="$1"; shift
	validate_repo_dir
	tag_name="$1"; shift
	validate_tag_name
	;;
	del)
	[ "$#" -le 1 ] || usage 'Too many arguments.'
	[ "$#" -ge 1 ] || usage 'Not enough arguments.'
	package="$1"; shift
	;;
	copy)
	[ "$#" -ge 1 ] || usage 'Not enough arguments.'
	package="$1"; shift
	copy_repo=
	if [ $# -ge 1 ]; then
		copy_repo="$1"; shift
	fi
	[ -n "$copy_repo" ] || copy_repo=sisyphus
	copy_repo="$(girar-normalize-repo-name "$copy_repo")"
	;;
	srpm)
	[ "$#" -le 1 ] || usage 'Too many arguments.'
	[ "$#" -ge 1 ] || usage 'Not enough arguments.'
	srpm="$1"; shift
	;;
	*) usage "Invalid action: $action" ;;
esac

cd "$GB_TASKS/$id"
# obtain an exclusive lock on the TASKS structure
builtin lockf -n . ||
	fatal "task #$id is locked"

repo="$(cat task/repo)"
case "$action" in
	del)
	girar-check-package-in-repo "$package" "$repo" ||
		fatal "Invalid request to delete nonexistent package \`$package' from \`$repo'"
	;;
	srpm)
	validate_srpm
	;;
	copy)
	[ "$repo" != "$copy_repo" ] ||
		fatal "Invalid request to copy package from \`$copy_repo' to \`$repo'"
	[ "$repo" != 'sisyphus' ] ||
		fatal "Invalid request to copy package to \`$repo'"
	girar-check-package-in-repo "$package" "$copy_repo" ||
		fatal "Invalid request to copy nonexistent package \`$package' from \`$copy_repo'"
	;;
esac

check_task_modifiable

nums=$(gear_nums)

check_already_added_repo()
{
	local i
	for i in $nums; do
		[ -s gears/$i/dir ] || return 0
		local a_dir a_tag_name a_tag_id
		a_dir=$(cat gears/$i/dir)
		a_tag_name=$(cat gears/$i/tag_name)
		a_tag_id=$(cat gears/$i/tag_id)
		if [ "${a_dir##*/}" = "${dir##*/}" ] &&
		   [ "$a_tag_name" = "$tag_name" ]; then
			[ "$a_tag_id" = "$tag_id" ] ||
				fatal "${dir##*/}: another tag $tag_name was already added (subtask #$i)"
			message "${dir##*/}: tag $tag_name was already added (subtask #$i)"
			exit 0
		fi
		if [ "$a_tag_id" = "$tag_id" ]; then
			# maybe added by another guy
			message "${dir##*/}: tag $tag_name was already added (subtask #$i, from $a_dir $a_tag_name)"
			exit 0
		fi
	done
}

check_already_added_package()
{
	local i
	for i in $nums; do
		[ -s gears/$i/package ] || continue
		local a_name a_copy
		a_name=$(cat gears/$i/package)
		[ "$a_name" = "$package" ] || continue
		a_copy="$(cat gears/$i/copy_repo 2>/dev/null ||:)"
		case "$action" in
			del)
			if [ -s gears/$i/copy_repo ]; then
				fatal "package $package was already queued by $(cat gears/$i/userid) for copy from $a_copy"
			else
				message "package $package was already queued by $(cat gears/$i/userid) for deletion"
				exit 0
			fi
			;;
			copy)
			if [ -s gears/$i/copy_repo ]; then
				message "package $package was already queued by $(cat gears/$i/userid) for copy from $a_copy"
				[ "$copy_repo" = "$a_copy" ] && exit 0
			else
				fatal "package $package was already queued by $(cat gears/$i/userid) for deletion"
			fi
			;;
		esac
	done
}

check_already_added()
{
	case "$action" in
		repo)
		check_already_added_repo
		;;
		del|copy)
		check_already_added_package
		;;
	esac
}

check_add_first()
{
	local task_owner
	task_owner=$(cat task/owner)
	[ "$GIRAR_USER" = "$task_owner" ] ||
		fatal "only $task_owner can add first subtask"
}

check_add_nth()
{
	[ -w gears ] ||
		fatal 'gears: Permission denied'
}

if [ -n "$nums" ]; then
	check_add_nth
	check_already_added
	i=$(printf %s "$nums" |tail -n1)
else
	check_add_first
	i=0
fi

i=$(($i+1))

logger -t "$PROG" "user=$GIRAR_USER task=$id subtask=$i"

atexit()
{
	local rc=$?
	trap - EXIT
	[ "$rc" -eq 0 ] || rm -rf gears/"$i"/ acl/"$i"/
	exit $rc
}

trap '' HUP INT QUIT PIPE TERM
# gears are not shared by default
mkdir -pm755 gears acl
mkdir -m2775 gears/"$i" acl/"$i"
trap atexit EXIT

case "$action" in
	del)
	printf '%s\n' "$package" >gears/$i/package
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	girar-make-task-index-html "$id"
	echo >&2 "task #$id: added #$i: delete package $package from $repo"
	exit 0
	;;
	copy)
	printf '%s\n' "$copy_repo" >gears/$i/copy_repo
	printf '%s\n' "$package" >gears/$i/package
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	girar-make-task-index-html "$id"
	echo >&2 "task #$id: added #$i: copy package $package from $copy_repo"
	exit 0
	;;
	srpm)
	mv -- "$HOME/incoming/tmp/$srpm" gears/$i/
	printf '%s\n' "$srpm" >gears/$i/srpm
	printf '%s\n' "$GIRAR_USER" >gears/$i/userid
	girar-make-task-index-html "$id"
	echo >&2 "task #$id: added #$i: build srpm $srpm"
	exit 0
	;;
esac

printf '%s\n' "$dir" >gears/$i/dir
printf '%s\n' "$tag_name" >gears/$i/tag_name
printf '%s\n' "$tag_id" >gears/$i/tag_id
printf '%s\n' "$tag_author" >gears/$i/tag_author
printf '%s\n' "$GIRAR_USER" >gears/$i/userid

GIT_DIR=gears/$i/git
export GIT_DIR
mkdir "$GIT_DIR"
git init -q --template=/var/empty
printf >&2 %s "fetching tag \"$tag_name\" from $dir... "
git fetch -q "$dir" tag "$tag_name"
echo >&2 done
git branch master "tags/$tag_name"
touch "$GIT_DIR/git-daemon-export-ok"

if [ -O gears ]; then
	# git directories should be writable by builder
	find "$GIT_DIR" -type d -execdir chmod g+w -- '{}' '+'
else
	# directories added to alien task should be writable by task owner
	find "gears/$i" -type d -execdir chmod g+w -- '{}' '+'
fi

pkg_tar="gears/$i/pkg.tar"
printf >&2 %s "generating pkg.tar for ${dir##*/} tag \"$tag_name\"... "
if env TZ=UTC gear -t "$tag_name" -- "$pkg_tar" &&
   [ -s "$pkg_tar" ]; then
	echo >&2 done
else
	rm -f "$pkg_tar"
	fatal "failed to create pkg.tar for ${dir##*/} tag \"$tag_name\""
fi

girar-make-task-index-html "$id"
echo >&2 "task #$id: added #$i: build tag \"$tag_name\" from $dir"
