#!/bin/sh -efu

. girar-sh-functions
PROG='girar-task add'

usage()
{
	[ -z "$*" ] || message "$*"
	echo >&2 "usage: $PROG [<task-id>] <gear-repo> <gear-tag>"
	exit 1
}

if [ "${1-}" = '--help' ]; then
	usage
fi

if [ "$#" -gt 3 ]; then
	usage 'Too many arguments.'
fi
if [ "$#" -lt 2 ]; then
	usage 'Not enough arguments.'
fi

id=
if [ "$#" -eq 3 ]; then
	id=$(girar-task-find-current "$1")
	shift
else
	id=$(girar-task-find-current)
fi

cd "$HOME"

dir0="$1"; shift
dir="${dir0#$PWD/}"
[ "${dir#/}" = "$dir" ] ||
	fatal "$dir0: path to git repository does not belong to allowed directory tree"

dir="$(validate_packages_dir "$dir")"
dir="$(add_git_suffix "$dir")"
[ -d "$dir" ] ||
	fatal "$dir0: directory not available"

[ -z "${dir%%packages/*}" ] ||
	fatal "$dir0: directory should belong to packages/ directory tree"

cd "$dir"

enable -f /usr/lib/bash/lockf lockf
# lock gear repo
builtin lockf -v .

tag_name="$1"; shift
GIT_DIR=. git rev-parse --symbolic --tags |fgrep -xqse "$tag_name" ||
	fatal "$tag_name: invalid tag name"
tag_id="$(git rev-parse --verify "$tag_name")"
GIT_DIR=. GNUPGHOME=/usr/lib/alt-gpgkeys git verify-tag "$tag_id" ||
	fatal "$tag_name: invalid tag"

if [ $# -gt 0 ]; then
	project_name="$1"; shift
else
	project_name="${PWD##*/}"
	project_name="${project_name%.git}"
fi
[ -n "$project_name" ] &&
printf %s "$project_name" |egrep -qs "$project_name_regexp" ||
	fatal "$project_name: invalid project name"

cd "$GIRAR_TASKS"

# no need to lock $GIRAR_TASKS
builtin lockf -v "$id"

seq=
if [ -f "$id"/task/seq ]; then
	seq=$(cat "$id"/task/seq)
	case "$(($seq%3))" in
		# awaiting for build
		0) ;;
		# work in progress
		1) fatal "task $id is a work in progress" ;;
		# have build results
		2) ;;
	esac
fi

# TODO: add gear repo to task.
fatal "$PROG not implemented"
