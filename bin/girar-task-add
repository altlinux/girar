#!/bin/sh -efu

. girar-sh-functions
. shell-quote
PROG='girar-task add'

usage()
{
	[ -z "$*" ] || message "$*"
	echo >&2 "usage: $PROG [<task-id>] <gear-repo> <gear-tag>"
	exit 1
}

if [ "${1-}" = '--help' ]; then
	usage
fi

if [ "$#" -gt 3 ]; then
	usage 'Too many arguments.'
fi
if [ "$#" -lt 2 ]; then
	usage 'Not enough arguments.'
fi

id=
if [ "$#" -eq 3 ]; then
	id=$(PROG="$PROG" girar-task-find-current "$1")
	shift
else
	id=$(PROG="$PROG" girar-task-find-current)
fi

cd "$HOME"

dir0="$1"; shift
dir="${dir0#$PWD/}"
[ "${dir#/}" = "$dir" ] ||
	fatal "$dir0: path to git repository does not belong to allowed directory tree"

dir="$(validate_packages_dir "$dir")"
dir="$(add_git_suffix "$dir")"
[ -d "$dir" ] ||
	fatal "$dir0: directory not available"

[ -z "${dir%%packages/*}" ] ||
	fatal "$dir0: directory should belong to packages/ directory tree"

enable -f /usr/lib/bash/lockf lockf

cd "$dir"
builtin lockf -v .
dir=$PWD

tag_name="$1"; shift
git rev-parse --symbolic --tags |fgrep -xqse "$tag_name" ||
	fatal "$tag_name: invalid tag name"
tag_id="$(git rev-parse --verify "$tag_name")"
if ! sig_text="$(GNUPGHOME=/usr/lib/alt-gpgkeys git verify-tag "$tag_id" 2>&1)"; then
	printf >&2 '%s\n' "$sig_text"
	fatal "$tag_name: invalid tag"
fi

domain=${EMAIL_DOMAIN%.*}
tag_author="$(printf %s "$sig_text" |
	LANG=C sed -n 's/^[^<]*[[:space:]]\(from\|aka\)[[:space:]][^<]\+<\([^@>]\+\)@'"$(quote_sed_regexp "$domain")"'\.[a-z]\+>[^>]*$/\2/p' |
	tr '[:upper:]' '[:lower:]' |tr - _ |sort -u)"
[ "$tag_author" = "$GIRAR_USER" ] ||
	fatal "$tag_name: unacceptable signature: $(printf %s "tag_author" |tr -s '[:space:]' ' ') (expected $GIRAR_USER@$domain)"

cd "$GB_TASKS/$id"
builtin lockf -nv . ||
	fatal "task #$id is locked"

seq=
if [ -f task/seq ]; then
	seq=$(cat task/seq)
	case "$(($seq%3))" in
		# awaiting for build
		0) ;;
		# work in progress
		1) fatal "task $id is a work in progress" ;;
		# have build results
		2) ;;
	esac
fi

gear_nums()
{
	set +f
	cd gears &&
	ls [1-9]*/dir |sort -n |cut -d/ -f1 ||:
}

nums=$(gear_nums 2>/dev/null)

check_already_added()
{
	local i a_dir a_tag_name a_tag_id
	for i in $nums; do
		a_dir=$(cat gears/$i/dir)
		a_tag_name=$(cat gears/$i/tag_name)
		a_tag_id=$(cat gears/$i/tag_id)
		if [ "${a_dir##*/}" = "${dir##*/}" ] &&
		   [ "$a_tag_name" = "$tag_name" ]; then
			message "${dir##*/}: tag $tag_name was already added"
			[ "$a_tag_id" = "$tag_id" ] ||
				fatal "${dir##*/}: tag $tag_name has changed"
			exit 0
		fi
		if [ "$a_tag_id" = "$tag_id" ]; then
			# maybe added by another guy
			message "${dir##*/}: tag $tag_name was already added (from $a_dir $a_tag_name)"
			exit 0
		fi
	done
}

check_add_first()
{
	local task_owner
	task_owner=$(cat task/owner)
	[ "$GIRAR_USER" = "$task_owner" ] ||
		fatal "only $task_owner can add 1st gear-repo"
}

check_add_nth()
{
	[ -w gears ] ||
		fatal "gears: permission denied"
}

if [ -n "$nums" ]; then
	check_add_nth
	check_already_added
	i=$(echo "$nums" |tail -n1)
else
	check_add_first
	i=0
fi

i=$(($i+1))

atexit()
{
	local rc=$?
	trap - EXIT
	[ "$rc" -eq 0 ] || rm -rf gears/"$i"/
	exit $rc
}

trap '' HUP INT QUIT PIPE TERM
# gears are not shared by default
mkdir -p -m755 gears
mkdir gears/"$i"
trap atexit EXIT
echo "$dir" >gears/$i/dir
echo "$tag_name" >gears/$i/tag_name
echo "$tag_id" >gears/$i/tag_id
echo "$tag_author" >gears/$i/tag_author

mkdir gears/$i/git
GIT_DIR=gears/$i/git git init -q
GIT_DIR=gears/$i/git git fetch -q -n "$dir" tag "$tag_name"

# directories added to alien task should be writable by task owner
[ -O gears ] ||
	find "gears/$i" -type d -execdir chmod g+w -- '{}' '+'

echo >&2 "task $id added gear-repo #$i $dir $tag_name"
