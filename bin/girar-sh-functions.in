#!/bin/sh

if [ -z "${__included_girar_sh_functions-}" ]; then
__included_girar_sh_functions=1

[ -z "${PATH##@CMD_DIR@:*}" -o -z "${PATH%%*:@CMD_DIR@}" ] ||
	PATH="@CMD_DIR@:$PATH"

. shell-error
. girar-sh-config

# If $1 contains no "/" symbol, prefix it with "packages/".
prefix_packages()
{
	local fmt='%s' dirname="${1%/*}"
	[ "$dirname" != "$1" ] ||
		fmt='packages/%s'
	printf "$fmt" "$1"
}

# If $1 doesn't end with ".git", append ".git" suffix.
add_git_suffix()
{
	local arg="$1"
	[ -z "${arg##*.git}" ] ||
		arg="$arg.git"
	printf %s "$arg"
}

validate_packages_dir()
{
	local dir0 dirname proj
	dir0="$(prefix_packages "$1")"; shift
	dirname="${dir0%/*}"
	[ "$dirname" = 'packages' -o "$dirname" = 'private' -o "$dirname" = 'public' ] ||
		fatal "$dir0: invalid directory name"
	proj="$dir0"
	proj="${proj%%/}"
	proj="${proj##*/}"
	proj="${proj%.git}"
	printf %s "$proj" |grep -Exqse "$PROJECT_NAME_REGEXP" ||
		fatal "$dir0: invalid directory name"
	printf '%s\n' "$dirname/$proj"
}

gear_nums()
{
	find gears -mindepth 2 -maxdepth 2 -path 'gears/[1-7]*/userid' -type f 2>/dev/null |
		cut -d/ -f2 |sort -n
}

check_task_modifiable()
{
	local state
	state=$(cat task/state)
	case "$state" in
		AWAITING|EPERM|FAILED|NEW|PENDING|POSTPONED|TESTED)
			;;
		BUILDING|COMMITTING)
			fatal "task #$id is a work in progress" ;;
		DONE)
			fatal "task #$id is already successfully processed" ;;
		*)
			fatal "task #$id is in unrecognized state \"$state\"" ;;
	esac
}

fi #__included_girar_sh_functions
