#!/bin/sh -efu

. girar-sh-functions

input_queue="$GIRAR_PUBLIC_QUEUE"
our_queue="$GIRAR_PRIVATE_QUEUE"
remote_queue="$UPRAVDOM_QUEUE"
remote_account="$UPRAVDOM_ACCOUNT"

remotelock="$remote_queue/.lock"

find_args="-mindepth 1 -maxdepth 1 -regextype posix-basic -regex '^.*/[[:digit:]]\+$' -type f -printf '%f\n'"

findin()
{
	eval find "\$1" $find_args |
		sort -n
}

findin_remote_queue()
{
	ssh -n "$remote_account" "find '$remote_queue' $find_args" |
		sort -n
}

exit_handler()
{
	local rc=$?
	trap - EXIT

	# unlock remote queue if and only if we own it
	ssh -n "$remote_account" "[ ! -d '$remotelock' -o ! -O '$remotelock' ] || rmdir -- '$remotelock'" ||
		message "$remote_account: $remotelock: unable to remove lockdir"

	exit $rc
}

enable -f /usr/lib/bash/lockf lockf
builtin lockf -v "$our_queue"
builtin lockf -v "$input_queue"

private_num="$(findin "$our_queue" |tail -1)"

[ -n "$private_num" ] &&
	private_num=$(($private_num+1)) ||
	private_num=0

# move tasks from public queue to private queue
for name in $(findin "$input_queue"); do
	task="$input_queue/$name"

	if [ ! -s "$task" ]; then
		rm -f -- "$task"
		continue
	fi

	if ! mv -- "$task" "$our_queue/$private_num"; then
		message "unable to move '$task' -> '$our_queue/$private_num'"
		continue
	fi

	private_num=$(($private_num+1))
done

trap exit_handler HUP PIPE INT QUIT TERM EXIT

# lock remote queue
ssh -n "$remote_account" "while ! mkdir -- '$remotelock'>/dev/null 2>&1; do sleep 1; done" ||
	fatal "unable to lock remote queue"

remote_num="$(findin_remote_queue |tail -1)"

[ -n "$remote_num" ] && 
	remote_num=$(($remote_num+1)) ||
	remote_num=0

# move tasks from private queue to remote queue
for name in $(findin "$our_queue"); do
	rsync -tp "$our_queue/$name" "$remote_account:$remote_queue/$remote_num" ||
		fatal "unable to forward task '$our_queue/$name' -> '$remote_account:$remote_queue/$remote_num': rc=$?"
	rm -f -- "$our_queue/$name"
	remote_num=$(($remote_num+1))
done
