#!/bin/sh -efu

. girar-sh-functions
PROG='girar-task run'

usage()
{
	[ -z "$*" ] || message "$*"
	echo >&2 "usage: $PROG [<task_id>]"
	exit 1
}

if [ "${1-}" = '--help' ]; then
	usage
fi

if [ "$#" -gt 1 ]; then
	usage 'Too many arguments.'
fi

cd "$GB_TASKS"

id="$(PROG="$PROG" girar-task-find-current "$@")"
cd "$id"

enable -f /usr/lib/bash/lockf lockf
# obtain an exclusive lock on the TASKS structure
builtin lockf -v .

if [ 'root' != "$GIRAR_USER" ]; then
	owner="$(cat task/owner)"
	[ "$owner" = "$GIRAR_USER" ] ||
		fatal "task #$id belongs to $owner"
fi

[ -s gears/1/dir -o -s gears/1/srpm -o -s gears/1/package ] ||
	fatal "cannot run empty task #$id"

seq=
if [ -f task/seq ]; then
	seq=$(cat task/seq)
	case "$(($seq%3))" in
		# awaiting for build
		0) fatal "task #$id already scheduled for run" ;;
		# work in progress
		1) fatal "task #$id is a work in progress" ;;
		# have build results
		2)
		if [ 0 = "$(cat task/rc)" ]; then
			fatal "task #$id is already successfully processed"
		fi
		seq=$(($seq+1)) ;;
	esac
else
	seq=0
fi

# create group writable directories for build results
mkdir -pm3775 build plan

# create group writable files required for build
(umask 002; touch task/log task/rc task/seq) || false

trap '' HUP INT QUIT PIPE TERM
printf '%s\n' "$seq" >task/seq

echo >&2 "task #$id: seq=$seq queued, result will be emailed to $(cat task/owner)@$EMAIL_DOMAIN"
