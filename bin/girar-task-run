#!/bin/sh -efu

. girar-sh-functions
. shell-args

PROG0="$PROG"
PROG='task run'

show_help()
{
	cat <<EOF
$PROG - queue a task for build

Usage: $PROG [options] [<task id>]

If no task id is specified, the latest task created by the current user
will be choosen.

Options:
  -m <word>     use the given <word> as the reason for this build;
  -m -          read full build reason message from stdin;
  --dry-run     stop right before queueing the task;
  --fail-early  stop building the task after the first error;
  --fail-late   do not stop building the task after the first error;
  --test-only   stop after test, do not commit the task;
  --commit      commit the task after tests;
  --hurry       enable undocumented swift mode;
  --unhurry     disable undocumented swift mode;
  --help        show this text and exit.
EOF
	exit
}

TEMP="$(getopt -n "$PROG" -o m: -l commit,dry-run,fail-early,fail-late,hurry,test-only,unhurry,help -- "$@")" ||
        show_usage
eval set -- "$TEMP"

dry_run=
fail_mode=
test_mode=
swift_mode=
task_msg=
while :; do
	case "${1-}" in
		--) shift; break ;;
		-m) shift
		    [ "$#" -ge 1 ] ||
			show_usage 'not enough arguments.'
		    task_msg="$1" ;;
		--dry-run) dry_run=1 ;;
		--fail-early|--fail-late) fail_mode="$1" ;;
		--commit|--test-only) test_mode="$1" ;;
		--hurry|--unhurry) swift_mode="$1" ;;
		--help) show_help ;;
		*) break;
	esac
	shift
done

if [ "$#" -gt 1 ]; then
	show_usage 'too many arguments.'
fi

if [ -n "$task_msg" ]; then
	task_msg="$(if [ "$task_msg" = '-' ]; then
			message 'Go ahead and type the text of your message.'
			cat
		else
			printf %s "$task_msg"
		fi |
			tr -cd '[:print:]\n' |
			tr -s '[:space:]' ' ' |
			head -c 1024)"
	task_msg="${task_msg% }"
	printf %s "$task_msg" |
		tr -cd '[:alpha:]' |
		grep -qs ^. ||
		fatal 'invalid message'
fi

cd "$TASKS_DIR"

id="$(PROG="$PROG" girar-task-find-current "$@")"
cd "$id"

# obtain an exclusive lock on the TASKS structure
exec <.
flock -n 0 ||
        fatal "task #$id is locked"

repo="$(cat task/repo)"
repo="$(girar-normalize-repo-name "$repo")"

# Source per-repository config file.
conf="$CONF_DIR/repo/$repo"
if [ -s "$conf" ]; then
	. "$conf"
fi

owner="$(cat task/owner)"
state="$(cat task/state)"

case "$state" in
	NEW|SWEPT|TESTED|EPERM|FAILED)
		;;
	AWAITING|POSTPONED)
		fatal "task #$id is already scheduled for run" ;;
	BUILDING|FAILING|PENDING|COMMITTING)
		fatal "task #$id is a work in progress" ;;
	DONE)
		fatal "task #$id is already successfully processed" ;;
	*)
		fatal "task #$id is in unrecognized state \"$state\"" ;;
esac

if [ -z "$test_mode" ]; then
	if [ -f task/test-only ]; then
		test_mode='--test-only'
	else
		test_mode='--commit'
	fi
fi

if [ -z "$swift_mode" ]; then
	if [ -f task/swift ]; then
		swift_mode='--hurry'
	else
		swift_mode='--unhurry'
	fi
fi

if [ "$test_mode $swift_mode" = '--commit --hurry' ]; then
	fatal 'cannot commit in a hurry'
fi

[ -n "$(find acl/approved -mindepth 1 -maxdepth 1 -name '[1-7]*' -type d 2>/dev/null)" ] ||
	fatal "cannot run empty task #$id"

check_acl()
{
	[ "$state" = EPERM -a -s plan/check_acl ] || return
	girar-check-task-perms "$id" || return
}

[ "$owner" = "$GIRAR_USER" ] ||
	girar-check-superuser "$repo" ||
		check_acl ||
			fatal "task #$id belongs to $owner"

nums=$(gear_nums)
delnums=
check_copy_del()
{
	local i package action a_repo rc=0
	for i in $nums; do
		[ -s gears/$i/package -a ! -s gears/$i/dir ] || continue
		package="$(cat gears/$i/package)"
		if [ -s gears/$i/copy_repo ]; then
			action=copy
			a_repo="$(cat gears/$i/copy_repo)"
		else
			action=delete
			a_repo=$repo
			delnums="$delnums $i"
		fi
		girar-check-package-in-repo "$package" "$a_repo" ||
		{
			message "task #$id: subtask #$i: invalid request to $action nonexistent package \`$package' from \`$a_repo'"
			rc=1
		}
	done
	return $rc
}

check_srpm()
{
	local i nevr s_name s_evr r_evr rc=0
	for i in $nums; do
		[ -s gears/$i/srpm -a -s gears/$i/nevr ] || continue
		nevr="$(cat gears/$i/nevr)"
		sid="$(cat gears/$i/sid)"
		GIRAR_ALLOW_SAME_NEVR=
		if [ -f gears/$i/rebuild ]; then
			GIRAR_ALLOW_SAME_NEVR=1
		fi
		s_name="${nevr%	*}"
		s_evr="${nevr#*	}"
		r_evr="$(GIRAR_ALLOW_SAME_NEVR=$GIRAR_ALLOW_SAME_NEVR \
			girar-check-nevr-in-repo "$s_name" "$s_evr" "$repo")" ||
		{
			message "task #$id: subtask #$i: package \`$(cat gears/$i/srpm)' is not newer than \`$s_name-$r_evr' in \`$repo'"
			rc=1
		}
		[ "$rc" -ne 0 ] ||
			girar-check-sid "$s_name" "$s_evr" "$sid" "$repo" || {
			case $? in
				1)
					message "package \`$s_name' version \`$s_evr' is already built but no source id has been recorded"
					rc=1
					;;
				2)
					message "package \`$s_name' version \`$s_evr' is already built from a different source"
					rc=1
					;;
			esac
		}
	done
	return $rc
}

check_depends()
{
	[ -f task/depends ] || return 0
	{
		# Obtain an exclusive lock on task/depends file.
		flock 0

		local i k rc=0
		for i in $(cat); do
			k="_$(($i/1024))"
			if [ -d "$TASKS_DIR/archive/done/$k/$i/task" ]; then
				girar-task-rmdep "$i"
			elif [ ! -d "$TASKS_DIR/$i/task" ]; then
				message "required task #$i not found"
				rc=1
			fi
		done
		return $rc
	} < task/depends
}

check_copy_del
check_srpm
check_depends

[ -n "$task_msg" ] ||
[ -s task/message ] || {
	[ -z "$delnums" ] ||
		show_usage "task #$id contains explicit package removals, please specify a reason for that"
	[ -z "${GIRAR_ACL_MAINT_GROUP-}" ] ||
	[ "$test_mode" = '--test-only' ] ||
		show_usage "a reason must be specified for '$repo' repository"
}

try=$(cat task/try 2>/dev/null ||:)
if [ -n "$try" ]; then
	try=$(($try+1))
else
	try=1
fi
iter=1

next_state=AWAITING
if [ "$state" = TESTED ] && [ "$test_mode" = '--commit' ]; then
	next_state=PENDING
fi
if [ "$next_state" = AWAITING -a -s task/depends ]; then
	next_state=POSTPONED
fi
if [ -n "$dry_run" ]; then
	echo >&2 "task #$id: try #$try could be placed to $next_state queue"
	exit 0
fi

# create group writable directories for build results
mkdir -pm3775 install logs mail mail/bugmail mail/cvemail report
mkdir -pm2775 arepo build plan

# create group writable files required for build
(umask 002; touch logs/events.$try.$iter.log task/iter task/try) || false

# set/remove fail-early flag if requested
case "$fail_mode" in
	--fail-early)
		[ -f task/fail-early ] ||
			touch task/fail-early
		;;
	--fail-late)
		[ ! -f task/fail-early ] ||
			rm task/fail-early
		;;
esac

# set/remove test-only flag if requested
case "$test_mode" in
	--test-only)
		[ -f task/test-only ] ||
			touch task/test-only
		;;
	--commit)
		[ ! -f task/test-only ] ||
			rm task/test-only
		;;
esac

# set/remove swift flag if requested
case "$swift_mode" in
	--hurry)
		[ -f task/swift ] ||
			touch task/swift
		;;
	--unhurry)
		[ ! -f task/swift ] ||
			rm task/swift
		;;
esac

# remove "abort" flag
rm -f task/abort

# save the message for posterity
[ -z "$task_msg" ] ||
	(umask 002; printf '%s\n' "$task_msg" > task/message) ||
	false

echo "$GIRAR_USER" > task/run

logger -t "$PROG0" "user=$GIRAR_USER task=$id try=$try repo=$repo"

trap '' HUP INT QUIT PIPE TERM
echo $try > task/try
echo 1 > task/iter
girar-task-change-state "$id" "$next_state"
girar-webapi-task update "$id"

echo >&2 "task #$id: try #$try is $next_state, result will be emailed to $owner@$EMAIL_DOMAIN"
