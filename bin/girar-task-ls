#!/bin/sh -efu

. girar-sh-functions
PROG='girar-task ls'

cd "$GB_TASKS"

enable -f /usr/lib/bash/lockf lockf

gear_nums()
{
	set +f
	cd gears 2>/dev/null &&
	ls [1-9]*/dir |sort -n |cut -d/ -f1 ||:
}

show_status()
{
	local seq
	seq="$(cat task/seq 2>/dev/null ||:)"
	if [ -z "$seq" ]; then
		printf ' NEW'
		return
	fi
	case "$(($seq%3))" in
		# awaiting for build
		0) printf ' AWAITING' ;;
		# work in progress
		1) printf ' BUILDING' ;;
		# have build results
		2)
		[ 0 = "$(cat task/rc 2>/dev/null)" ] &&
			printf ' DONE' ||
			printf ' FAILED'
		;;
	esac
}

ls1()
{
	local id="$1"; shift
	cd "$id" || return
	printf '#%d' "$id"
	show_status
	if ! (builtin lockf -n . ); then
		printf ' [locked]'
	fi
	find gears -maxdepth 0 -path gears -type d -perm -g=w -printf ' [shared]' 2>/dev/null ||:
	printf ' %s' "$(cat task/repo)"
	local i dir tag_name
	for i in $(gear_nums); do
		dir=$(cat gears/$i/dir)
		tag_name=$(cat gears/$i/tag_name)
		printf ' %s=%s' "${dir##*/}" "$tag_name"
	done
	printf '\n'
}

ids=$(set +f; fgrep -lx "$GIRAR_USER" [1-9]*/task/owner 2>/dev/null |
       sort -rn |cut -d/ -f1)

if [ -z "$ids" ]; then
	message "no tasks for $GIRAR_USER"
else
	for id in $ids; do
		(ls1 "$id")
	done
fi
