#!/bin/sh -efu

. girar-sh-functions

[ -n "${GIRAR_USER-}" ] ||
	fatal 'GIRAR_USER undefined'

. shell-args

PROG=build

show_help()
{
cat <<EOF
$PROG - create a task, add subtasks, and queue for build.

Usage: $PROG [options] <build_instruction_1> ...

where each <build_instruction_N> is either
\`<gear_repo> <gear_tag>' or \`<gear_repo>.git=<gear_tag>'
or \`srpm <srpm_file>' or \`<srpm_file_without_suffix>.src.rpm'
or \`rebuild <package_name>' or \`del <package_name>'
or \`copy <package_name>'.

Options:
  -m <message>    use the given <message> as the reason for this build;
  -b <binary_repository_name>     set a target binary package repository;
  --deps <deps>   set a comma-separated list of required task id numbers;
  --fail-early    stop building the task after the first error;
  --test-only     stop building the task after tests, do not commit;
  --help          show this text and exit.
EOF
	exit
}

TEMP="$(getopt -n "$PROG" -o b:m: -l deps:,fail-early,test-only,help -- "$@")" ||
	show_usage
eval set -- "$TEMP"

deps=
repo=
fail_early=
test_only=
task_msg=
while :; do
	case "$1" in
		--) shift; break ;;
		-b) shift; repo="$1" ;;
		-m) shift; task_msg="$1" ;;
		--deps) shift; deps="$1" ;;
		--fail-early) fail_early="$1" ;;
		--test-only) test_only="$1" ;;
		--help) show_help ;;
		*) show_usage "unrecognized option: $1" ;;
	esac
	shift
done

[ $# -ge 1 ] ||
	show_usage 'not enough arguments.'

atexit()
{
	local rc=$?
	trap - EXIT
	[ "$rc" -eq 0 ] || girar-task rm "$id"
	exit $rc
}

trap '' HUP INT QUIT PIPE TERM
id="$(girar-task new "$repo")"
trap atexit EXIT

if [ -n "$deps" ]; then
	girar-task deps "$id" set $(printf %s "$deps" |tr , ' ')
fi

# Basic sanity check.
cmd=
for arg; do
	[ -n "$arg" ] ||
		show_usage 'invalid empty argument.'
	if [ -n "$cmd" ]; then
		cmd=
	else
		case "$arg" in
			*.git=*|*.src.rpm)
				cmd= ;;
			*)
				cmd="$arg" ;;
		esac
	fi
done
[ -z "$cmd" ] ||
	show_usage 'not enough arguments.'

cmd=
for arg; do
	case "$cmd" in
		'')
			case "$arg" in
				*.git=*|*.src.rpm)
					girar-task add "$id" "$arg"
					cmd= ;;
				*)
					cmd="$arg" ;;
			esac
			;;
		copy|del|rebuild|srpm)
			girar-task add "$id" "$cmd" "$arg"
			cmd= ;;
		*)
			girar-task add "$id" repo "$cmd" "$arg"
			cmd= ;;
	esac
done

set -- $fail_early $test_only
[ -z "$task_msg" ] ||
	set -- "$@" -m "$task_msg"
girar-task run "$@" "$id"
