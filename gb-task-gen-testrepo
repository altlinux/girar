#!/bin/sh -efu

. gb-sh-functions

# Use a fixed path so that genpkglist md5cache works.
repo="$TMPDIR/gb-repo-$GB_REPO_NAME"
rm -rf "$repo"
mkdir "$repo"

# Prepare skeleton.
for arch in i586 x86_64 noarch; do
	mkdir $repo/$arch
	# Copy base directory, except for contents_index.
	rsync -a --exclude contents_index $GB_REPO_DIR/$arch/base $repo/$arch/
	# Deal with RPMS and SRPMS.
	if cut -f3 plan/{add,rm}-bin |fgrep -qs "$arch"; then
		# Need to copy directory structure (using symlinks).
		cp -prs $GB_REPO_DIR/$arch/{RPMS,SRPMS}.classic $repo/$arch/
	else
		# Arch packages unchanged, no need to copy directory structure.
		ln -s $GB_REPO_DIR/$arch/{RPMS,SRPMS}.classic $repo/$arch/
	fi
done

# Commit packages.  This is a light-weight reimplementation
# of gb-y-task-commit-packages.  For tmprepo, we omit files/
# and update only RPMS.classic components.
while read -r N EVR A F; do
	rm -- $repo/$A/RPMS.classic/$F
done <plan/rm-bin
while read -r N EVR A F; do
       bin=$(findbin "$F")
       # NB: copy here, so that the repo is rsyncable to remotes.
       cp -p -- $PWD/$bin $repo/$A/RPMS.classic/$F
done <plan/add-bin

# SRPMS.classic is also updated here, since we want to reuse
# test repo base directories later in gb-task-commit-repo.
# However, we omit SRPMS.all update.
while read -r F A; do
	rm -- $repo/$A/SRPMS.classic/$F
done <plan/rm-srpm2arch
while read -r F A; do
	src=$(findsrc "$F")
	# NB: copying is not needed here.
	ln -s -- $PWD/$src $repo/$A/SRPMS.classic/$F
done <plan/add-srpm2arch

# Regen repo.
gb-y-repo-regen-basedir "$repo"

# basedir ok, SRPMS no longer needed
rm -r $repo/{i586,x86_64,noarch}/SRPMS.classic

# Optimize even more: the whole arch component can be turned into symlink.
for arch in i586 x86_64 noarch; do
	if cut -f3 plan/{add,rm}-bin |fgrep -qs "$arch"; then
		# Arch packages changed, cannot optimize.
		continue
	fi
	if cmp -s {$GB_REPO_DIR,$repo}/$arch/base/pkglist.classic.xz; then
		rm -r $repo/$arch
		ln -s $GB_REPO_DIR/$arch $repo/
	fi
done

stamp_echo >&2 'created test repo'
