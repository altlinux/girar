#!/bin/sh -efu

. gb-sh-functions

find_state="$1"; shift
next_state="$1"; shift
min_iter="$1"; shift

canon_state="$(printf %s "$find_state" |tr '[:upper:]' '[:lower:]')"
[ -n "$canon_state" ]

cd "$GB_TASKS_DIR"
enable -f /usr/lib/bash/lockf lockf

repo_tasks()
{
	cd index/"$GB_REPO_NAME/$canon_state"
	ls | sort -n
}

nums()
{
	find gears -mindepth 2 -maxdepth 2 \( -path 'gears/[1-7]*/dir' -or -path 'gears/[1-7]*/srpm' -or -path 'gears/[1-7]*/package' \) -type f 2>/dev/null |
		cut -d/ -f2 |sort -n
}

select_task()
{
	local id="$1"; shift
	local find_state="$1"; shift
	local next_state="$1"; shift
	cd "$id" 2>/dev/null
	# obtain an exclusive lock on the TASKS structure
	# if the lock cannot be immediately acquired, fail
	builtin lockf -n .

	# if skip flag is set, fail
	[ ! -f task/skip ] || exit

	# if task state doesn't match, fail
	[ "$(cat task/state)" = "$find_state" ] || exit

	# if task iteration number is less than required minimum, fail
	local iter
	iter="$(grep -h '^[1-9][0-9]*$' task/iter)"
	[ "$iter" -ge "$min_iter" ] || exit

	# find out who is the real owner of the task
	owner="$(stat -c %U .)"

	# create the per-owner-and-state file
	(umask 002 && touch "$GB_SPOOL_PEOPLE_DIR/$owner.$next_state") || exit

	# obtain an exclusive lock on the per-owner-and-state file,
	# if the lock cannot be immediately acquired, fail
	builtin lockf -n "$GB_SPOOL_PEOPLE_DIR/$owner.$next_state"

	# if no non-empty subtasks found, fail
	set -- $(nums)
	[ $# -ge 1 ]

	gb-task-validate-state "$canon_state"

	gb-girar task-change-state "$id" "$next_state" ||
		halt_build_queue
}

for id in $(repo_tasks); do
	(select_task "$id" "$find_state" "$next_state") ||
		continue
	echo "$id"
	break
done
