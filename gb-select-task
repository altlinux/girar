#!/bin/sh -efu

. gb-sh-functions

find_state="$1"; shift
next_state="$1"; shift

cd "$GB_TASKS_DIR"

enable -f /usr/lib/bash/lockf lockf
# obtain a shared lock on the whole TASKS directory
builtin lockf -s .

repo_tasks()
{
	find . -mindepth 3 -maxdepth 3 -path './[1-9]*/task/repo' -type f -print0 |
		xargs -r0 fgrep -i -l -x -e "$GB_REPO_NAME" -- |
		cut -d/ -f2 |sort -n
}

nums()
{
	find gears -mindepth 2 -maxdepth 2 \( -path 'gears/[1-9]*/dir' -or -path 'gears/[1-9]*/srpm' -or -path 'gears/[1-9]*/package' \) -type f 2>/dev/null |
		cut -d/ -f2 |sort -n
}

select_task()
{
	local id="$1"; shift
	local find_state="$1"; shift
	local next_state="$1"; shift
	cd "$id" 2>/dev/null
	# obtain an exclusive lock on the TASKS structure
	# if the lock cannot be immediately acquired, fail
	builtin lockf -n .

	# if skip flag is set, fail
	[ ! -f task/skip ]

	# if task state doesn't match, fail
	[ "$(cat task/state)" = "$find_state" ]

	# if no non-empty subtasks found, fail
	set -- $(nums)
	[ $# -ge 1 ]

	echo "$next_state" > task/state ||
		halt_build_queue
}

for id in $(repo_tasks); do
	(select_task "$id" "$find_state" "$next_state")
	if [ $? -eq 0 ]; then
		echo "$id"
		exit
	fi
done
