#!/bin/sh -efu

. gb-sh-functions

find_state="$1"; shift
next_state="$1"; shift

canon_state="$(printf %s "$find_state" |tr '[:upper:]' '[:lower:]')"
[ -n "$canon_state" ]

cd "$GB_TASKS_DIR"
enable -f /usr/lib/bash/lockf lockf

repo_tasks()
{
	cd index/"$canon_state"
	find -L . -mindepth 3 -maxdepth 3 -path './[1-9]*/task/repo' -type f -print0 |
		xargs -r0 fgrep -i -l -x -e "$GB_REPO_NAME" -- |
		cut -d/ -f2 |sort -n
}

nums()
{
	find gears -mindepth 2 -maxdepth 2 \( -path 'gears/[1-7]*/dir' -or -path 'gears/[1-7]*/srpm' -or -path 'gears/[1-7]*/package' \) -type f 2>/dev/null |
		cut -d/ -f2 |sort -n
}

select_task()
{
	local id="$1"; shift
	local find_state="$1"; shift
	local next_state="$1"; shift
	cd "$id" 2>/dev/null
	# obtain an exclusive lock on the TASKS structure
	# if the lock cannot be immediately acquired, fail
	builtin lockf -n .

	# if skip flag is set, fail
	[ ! -f task/skip ]

	# if task state doesn't match, fail
	[ "$(cat task/state)" = "$find_state" ]

	# find out who is the real owner of the task
	owner="$(stat -c %U .)"

	# create the per-owner-and-state file
	(umask 002 && touch "$GB_SPOOL_PEOPLE_DIR/$owner.$next_state") || exit

	# obtain an exclusive lock on the per-owner-and-state file,
	# if the lock cannot be immediately acquired, fail
	builtin lockf -n "$GB_SPOOL_PEOPLE_DIR/$owner.$next_state"

	# if no non-empty subtasks found, fail
	set -- $(nums)
	[ $# -ge 1 ]

	gb-girar task-change-state "$id" "$next_state" ||
		halt_build_queue
}

for id in $(repo_tasks); do
	(select_task "$id" "$find_state" "$next_state")
	if [ $? -eq 0 ]; then
		echo "$id"
		exit
	fi
done
