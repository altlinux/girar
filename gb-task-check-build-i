#!/bin/sh -efu

. gb-sh-functions

i="$1"; shift

built=
userid="$(cat "gears/$i/userid")"
if [ -s "gears/$i/dir" ]; then
	dir="$(cat "gears/$i/dir")"
	I="${dir##*/} $(cat "gears/$i/tag_name")"
	built=1
elif [ -s "gears/$i/srpm" ]; then
	I="$(cat "gears/$i/srpm")"
	built=1
elif [ -s "gears/$i/copy_repo" -a -s "gears/$i/package" ]; then
	I="$(cat "gears/$i/copy_repo") $(cat "gears/$i/package")"
else
	stamp_echo >&2 "#$i: source not found"
	exit 1
fi

Fatal()
{
	stamp_echo >&2 "$I: $*"
	exit 1
}

cd build/$i

check_srpms()
{
	set +f
	for arch in i586 x86_64; do
		set -- $arch/srpm/*.src.rpm
		if [ $# -gt 1 ]; then
			Fatal "multiple $arch source packages:" "$@"
		fi
		if [ -f "$1" ]; then
			echo "${1##*/}"
		else
			[ -s "$arch/excluded" ] ||
				Fatal "no $arch source package"
		fi
	done
}

srpms=$(check_srpms)
n=$(echo "$srpms" |sort -u |wc -l)

[ "$n" -eq 1 ] ||
	Fatal 'different per-arch srpms:' $srpms

noarch()
{
	local arch="$1"; shift
	find "$arch/rpms" -mindepth 1 -maxdepth 1 -name '*.noarch.rpm' -type f -printf '%f\n' 2>/dev/null ||:
}

. gb-sh-tmpdir

noarch i586 >"$tmpdir/i586.noarch"
noarch x86_64 >"$tmpdir/x86_64.noarch"
(cd "$tmpdir" && diff -U1 {i586,x86_64}.noarch ) ||
	Fatal 'different set of noarch packages'

dump_noarch()
{
	F='[%{FILENAMES}\n]'
	R='[Requires: %{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]'
	P='[Provides: %{PROVIDENAME} %{PROVIDEFLAGS:depflags} %{PROVIDEVERSION}\n]'
	O='[Obsoletes: %{OBSOLETENAME} %{OBSOLETEFLAGS:depflags} %{OBSOLETEVERSION}\n]'
	C='[Conflicts: %{CONFLICTNAME} %{CONFLICTFLAGS:depflags} %{CONFLICTVERSION}\n]'
	rpmquery --qf "$F$R$P$O$C" -p "$1"
}

while read -r rpm; do
	dump_noarch i586/rpms/"$rpm" >$tmpdir/$rpm.i586
	dump_noarch x86_64/rpms/"$rpm" >$tmpdir/$rpm.x86_64
	(cd "$tmpdir" && diff -U1 $rpm.{i586,x86_64} ) ||
		Fatal 'noarch packages mismatch'
done <$tmpdir/i586.noarch

for r in $GB_REPO_UP_NAME $GB_REPO_DOWN_NAME; do
	cd "$tmpdir"
	make_repo_table $r
	sort -k1,1 -o $r.src{,}
	sort -k1,1 -o $r.bin{,}
	cd - >/dev/null
done

check_release_name()
{
	local r="$1"; shift
	local s

	for s in $GB_REPO_REL_SUFF_MUST_NOT; do
		[ -n "${r##$s}" ] ||
			Fatal "release name $r contains $s suffix"
	done
	for s in $GB_REPO_REL_SUFF_MUST_HAVE; do
		[ -z "${r##$s}" ] ||
			Fatal "release name $r does not contain $s suffix"
	done
}

check_nevr()
{
	local t="$1"; shift
	local n="$1"; shift
	local evr="$1"; shift
	local r evr0

	for r in $GB_REPO_UP_NAME; do
		printf '%s\t%s\n' "$n" "$evr" |join -t$'\t' -o '2.2' - "$tmpdir/$r.$t" |sort -u >"$tmpdir/evr"
		while read -r evr0; do
			vercheck "$evr" "$evr0" ||
				Fatal "package $n-$evr is not older than \`$r' package $n-$evr0"
		done <"$tmpdir/evr"
	done
	for r in $GB_REPO_DOWN_NAME; do
		printf '%s\t%s\n' "$n" "$evr" |join -t$'\t' -o '2.2' - "$tmpdir/$r.$t" |sort -u >"$tmpdir/evr"
		while read -r evr0; do
			vercheck "$evr0" "$evr" ||
				Fatal "package $n-$evr is not newer than \`$r' package $n-$evr0"
		done <"$tmpdir/evr"
	done
}

for arch in i586 x86_64; do
	for d in $arch/srpm $arch/rpms; do
		if [ ! -d "$d" -a -s "$arch/excluded" ]; then
			continue
		fi
		sisyphus_check "$d" ||
			Fatal 'sisyphus_check FAILED'
	done

	# additional checks for built packages
	[ -n "$built" ] || continue

	# check changelog name
	find "$arch/" -type f -name '*.rpm' -execdir check-rpm-changelogname "$userid" '{}' '+' ||
		Fatal 'changelog name check FAILED'

	# check release name
	if [ -d "$arch/srpm" -o ! -s "$arch/excluded" ]; then
		qsrc "$arch/srpm/" >"$tmpdir/new.src"
		while read -r N EVR F; do
			check_release_name "${EVR##*-}"
			check_nevr src "$N" "$EVR"
		done <"$tmpdir/new.src"
	fi

	if [ -d "$arch/rpms" -o ! -s "$arch/excluded" ]; then
		qbin "$arch/rpms/" >"$tmpdir/new.bin"
		while read -r N EVR A F src_F; do
			check_release_name "${EVR##*-}"
			check_nevr bin "$N" "$EVR"
		done <"$tmpdir/new.src"
	fi
done
