#!/bin/sh -efu

. gb-sh-functions

i="$1"; shift

built=
userid="$(cat "gears/$i/userid")"
if [ -s "gears/$i/dir" ]; then
	dir="$(cat "gears/$i/dir")"
	I="${dir##*/} $(cat "gears/$i/tag_name")"
	built=1
elif [ -s "gears/$i/srpm" ]; then
	I="$(cat "gears/$i/srpm")"
	built=1
elif [ -s "gears/$i/copy_repo" -a -s "gears/$i/package" ]; then
	I="$(cat "gears/$i/copy_repo") $(cat "gears/$i/package")"
else
	stamp_echo >&2 "#$i: source not found"
	exit 1
fi

Fatal()
{
	stamp_echo >&2 "$I: $*"
	exit 1
}

cd build/$i

check_srpms()
{
	set +f
	for arch in i586 x86_64; do
		set $arch/srpm/*.src.rpm
		if [ $# -gt 1 ]; then
			Fatal "multiple $arch source packages:" "$@"
		fi
		[ -f "$1" ] ||
			Fatal "no $arch source package"
		echo "${1##*/}"
	done
}

srpms=$(check_srpms)
n=$(echo "$srpms" |sort -u |wc -l)

[ "$n" -eq 1 ] ||
	Fatal 'different per-arch srpms:' $srpms

noarch()
{
	set +f
	local arch="$1"; shift
	(cd $arch/rpms && ls *.noarch.rpm 2>/dev/null) ||:
}

. gb-sh-tmpdir

noarch i586 >"$tmpdir/i586.noarch"
noarch x86_64 >"$tmpdir/x86_64.noarch"
(cd "$tmpdir" && diff -U1 {i586,x86_64}.noarch ) ||
	Fatal 'different set of noarch packages'

dump_noarch()
{
	F='[%{FILENAMES}\n]'
	R='[Requires: %{REQUIRENAME} %{REQUIREFLAGS:depflags} %{REQUIREVERSION}\n]'
	P='[Provides: %{PROVIDENAME} %{PROVIDEFLAGS:depflags} %{PROVIDEVERSION}\n]'
	O='[Obsoletes: %{OBSOLETENAME} %{OBSOLETEFLAGS:depflags} %{OBSOLETEVERSION}\n]'
	C='[Conflicts: %{CONFLICTNAME} %{CONFLICTFLAGS:depflags} %{CONFLICTVERSION}\n]'
	rpmquery --qf "$F$R$P$O$C" -p "$1"
}

while read -r rpm; do
	dump_noarch i586/rpms/"$rpm" >$tmpdir/$rpm.i586
	dump_noarch x86_64/rpms/"$rpm" >$tmpdir/$rpm.x86_64
	(cd "$tmpdir" && diff -U1 $rpm.{i586,x86_64} ) ||
		Fatal 'noarch packages mismatch'
done <$tmpdir/i586.noarch

cmp_repo=
case "$GB_REPO_NAME" in
	sisyphus) cmp_repo=5.0 ;;
	5.0) cmp_repo=sisyphus ;;
esac
if [ -n "$cmp_repo" ]; then
	cd "$tmpdir"
	make_repo_table "$cmp_repo" repo
	sort -k1,1 -o repo.src{,}
	sort -k1,1 -o repo.bin{,}
	cd - >/dev/null
fi

check_release_name()
{
	local r="$1"; shift

	case "$GB_REPO_NAME" in
		sisyphus)
			[ -n "${r##*.M50*}" ] ||
				Fatal "release name $r contains 5.0-specific suffix"
			;;
		5.0)
			[ -z "${r##*.M50.*}" ] ||
				Fatal "release name $r does not contain 5.0-specific suffix"
			;;
	esac
}

check_nevr()
{
	local f="$1"; shift
	local n="$1"; shift
	local evr="$1"; shift
	local evr0

	printf '%s\t%s\n' "$n" "$evr" |join -t$'\t' -o '2.2' - "$f" |sort -u >"$tmpdir/evr"
	while read evr0; do
		case "$GB_REPO_NAME" in
			sisyphus)
				vercheck "$evr0" "$evr" ||
					Fatal "package $n-$evr is not newer than \"$cmp_repo\" package $n-$evr0"
				;;
			5.0)
				vercheck "$evr" "$evr0" ||
					Fatal "package $n-$evr is not older than \"$cmp_repo\" package $n-$evr0"
				;;
		esac
	done <"$tmpdir/evr"
}

for arch in i586 x86_64; do
	sisyphus_check $arch/srpm $arch/rpms ||
		Fatal 'sisyphus_check FAILED'

	# additional checks for built packages
	[ -n "$built" ] || continue

	# check changelog name
	find "$arch/" -type f -name '*.rpm' -execdir check-rpm-changelogname "$userid" '{}' '+' ||
		Fatal 'changelog name check FAILED'

	# check release name
	qsrc "$arch/srpm/" >"$tmpdir/new.src"
	while read N EVR F; do
		check_release_name "${EVR##*-}"
		check_nevr "$tmpdir/repo.src" "$N" "$EVR"
	done <"$tmpdir/new.src"

	qbin "$arch/rpms/" >"$tmpdir/new.bin"
	while read N EVR A F src_F; do
		check_release_name "${EVR##*-}"
		check_nevr "$tmpdir/repo.bin" "$N" "$EVR"
	done <"$tmpdir/new.src"
done
