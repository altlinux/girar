#!/bin/sh -efu

. gb-sh-functions

# Drop old plan if any.
find plan -type f -delete

# Make a plan for upgrade: assuming that all new packages go
# into the repo, find out the existing packages which should
# be replaced or removed.

. gb-sh-tmpdir

for i in $(build_nums); do
	for arch in $GB_ARCH; do
		if [ -d "build/$i/$arch/srpm" -o ! -s "build/$i/$arch/excluded" ]; then
			qsrc build/$i/$arch/srpm/
		fi
	done
done >$tmpdir/new.src

for i in $(build_nums); do
	for arch in $GB_ARCH; do
		if [ -d "build/$i/$arch/rpms" -o ! -s "build/$i/$arch/excluded" ]; then
			qbin build/$i/$arch/rpms/
		fi
	done
done >$tmpdir/new.bin

for i in $(package_nums); do
	[ -s gears/$i/copy_repo ] ||
		cat gears/$i/package
done >$tmpdir/del.pkg

cd "$tmpdir"

sort -u -o new.src{,}
sort -u -o new.bin{,}
sort -u -o del.pkg{,}

make_repo_table '' old

# check del.pkg consistency
sort -k1,1 -o old.src{,}
join -v1 del.pkg old.src >del.missing
if [ -s del.missing ]; then
	stamp_echo >&2 "FAILED to delete non-existent packages: $(cat del.missing)"
	exit 1
fi
sort -k1,1 -o new.src{,}
join -o 1.1 del.pkg new.src >del.new
if [ -s del.new ]; then
	stamp_echo >&2 "FAILED to delete just built packages: $(cat del.new)"
	exit 1
fi

mktable new

# Tuples are replaced
# 1) by explicit delete request
O='1.1 1.2 1.3 1.4 1.5 1.6 1.7'
join -t$'\t' -o "$O" -j 1 old del.pkg >rm-by-del
sort -u -o rm-by-del{,}

# 2) by explicit src-N match (src->bin+);
join -t$'\t' -o "$O" -j 1 old new >rm-by-src
sort -u -o rm-by-src{,}

# 3) by implicit bin-N match (src<-bin).
sort -k4,4 -o old{,}
sort -k4,4 -o new{,}
join -t$'\t' -o "$O" -j 4 old new >rm-by-bin
sort -u -o rm-by-bin{,}

# Implicit match can be wrong, so issue a warning.
comm -23 rm-by-{bin,src} >rm-by-bin-only
if [ -s rm-by-bin-only ]; then
	echo ' *** Warning: existing src.rpm kicked by new non-matching rpm'
	cut -f3,4 <rm-by-bin-only |sort -u
fi >&2

# Implicit (src<-bin) match should be propagated to (src->bin+).
sort -u -o old{,}
sort -u -o rm-by-bin{,}
join -t$'\t' -o "$O" -j 1 old rm-by-bin >rm-by-bin+

# Replaced tuples.
sort -u rm-by-{del,src,bin+} >rm

# Save pairs: old src-N, their new non-matching src-F replacers
sort -k4,4 -o rm-by-bin-only{,}
# join by bin-N, output: src1-N  src2-F
join -t$'\t' -o '1.1 2.3' -j 4 rm-by-bin-only new |
	sort -u >oldsrc2newsrpm

# Prepare new repo lists to update old.src/old.bin

# Apply add-src and rm-src changes to old.src
# sort by src-F
cat old.src >old+add.src
cut -f1-3 <new |sort -u >>old+add.src
sort -u -o old+add.src{,}
sort -k3,3 -o old+add.src{,}
cut -f3 <rm |sort -u >rm.src
# join by src-F
join -t$'\t' -o '1.1 1.2 1.3' -v1 -1 3 -2 1 old+add.src rm.src >next.src

# Apply add-bin and rm-bin changes to old.bin
cat old.bin >old+add.bin
# reorder columns to make src-F a last one
cut -f3-7 <new |sort -u |join -t$'\t' -o '1.2 1.3 1.4 1.5 1.1' -v1 - /dev/null >>old+add.bin
sort -u -o old+add.bin{,}
# sort by bin-F
sort -k4,4 -o old+add.bin{,}
cut -f7 <rm |sort -u >rm.bin
# join by bin-F
join -t$'\t' -o '1.1 1.2 1.3 1.4 1.5' -v1 -1 4 -2 1 old+add.bin rm.bin >next.bin

# Guess what.  The plan is actually about moving some files around.
cd - >/dev/null

# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-A  bin-F
cut -f1-7 <$tmpdir/new |sort -u >plan/add-src+bin
# src-N  src-EVR  src-F
cut -f1-3 <$tmpdir/new |sort -u >plan/add-src
# src-F  bin-A
cut -f3,6 <$tmpdir/new |sort -u >plan/add-srpm2arch
# bin-N  bin-EVR  bin-A  bin-F
cut -f4-7 <$tmpdir/new |sort -u >plan/add-bin

cut -f1-7 <$tmpdir/rm |sort -u >plan/rm-src+bin
cut -f1-3 <$tmpdir/rm |sort -u >plan/rm-src
cut -f3,6 <$tmpdir/rm |sort -u >plan/rm-srpm2arch
cut -f4-7 <$tmpdir/rm |sort -u >plan/rm-bin
cat <$tmpdir/oldsrc2newsrpm >plan/oldsrc2newsrpm

sort -u "$tmpdir/next.src" >plan/next.src
if [ -s "$GB_REPO_DIR/files/list/src.list" ]; then
	diff -u "$GB_REPO_DIR/files/list/src.list" plan/next.src >plan/src.list.diff ||:
fi
sort -u "$tmpdir/next.bin" >plan/next.bin
if [ -s "$GB_REPO_DIR/files/list/bin.list" ]; then
	diff -u "$GB_REPO_DIR/files/list/bin.list" plan/next.bin >plan/bin.list.diff ||:
fi

# This operation is quite fast, no need to stamp.
exit 0
