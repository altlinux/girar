#!/bin/sh -efu

# Make a plan for upgrade: assuming that all new packages go
# into the repo, find out the existing packages which should
# be replaced or removed.

N="%{NAME}"
VR="%{VERSION}-%{RELEASE}"
EVR="%|EPOCH?{%{EPOCH}:}|$VR"
NVR="%{NAME}-$VR"
A="%{ARCH}"

qsrc()
{
	# src-N  src-EVR  src-F
	find "$@" -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$NVR.src.rpm\n" -p --
}

qbin()
{
	# bin-N  bin-EVR  bin-A  bin-F  src-F
	find "$@" -name '*.rpm' -not -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$A\t$NVR.$A.rpm\t%{SOURCERPM}\n" -p --
}

. gb-sh-tmpdir

set +f
qsrc build/*/*/srpm/ >$tmpdir/new.src
qbin build/*/*/rpms/ >$tmpdir/new.bin
set -f

. gb-sh-repo-conf

enable -f /usr/lib/bash/lockf lockf
# obtain a shared lock on the $GB_REPO_DIR
builtin lockf -s -v "$GB_REPO_DIR"

qsrc $GB_REPO_DIR/{i586,x86_64,noarch}/SRPMS.classic/ >$tmpdir/old.src
qbin $GB_REPO_DIR/{i586,x86_64,noarch}/RPMS.classic/ >$tmpdir/old.bin

cd "$tmpdir"
sort -u -o new.src{,}
sort -u -o new.bin{,}
sort -u -o old.src{,}
sort -u -o old.bin{,}

# Now what's the plan?  I guess we don't just move some files around.
# We deal with "tuples" (src,bin+).  Therefore, the consistent plan is
# to group files into such tuples, and decide how new tuples replace
# the existing tuples.
#
# Thus we have to assume that the repo is consistent: both src->bin+
# and bin->src mappings must exist for every package in the repo.  Stale
# packages cannot be handled by the plan consistently, and removing them
# is someone else's job.
#
# Tuples are represented with the following table:
#
# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-A  bin-F
# -----  -------  -----  -----  -------  -----  -----
#
# Note: the fact that both mappings mentioned above exist roughly means
# that we can join src+bin on %{SOURCERPM}.  This is how we do the table.

mktable()
{
	local x="$1"; shift
	# sort by src-F field
	sort -k3 -o $x.src{,}
	sort -k5 -o $x.bin{,}
	# join by src-F field
	join -t$'\t' -13 -25 -o '1.1 1.2 1.3 2.1 2.2 2.3 2.4' $x.{src,bin} >$x
	sort -u -o $x{,}
}

mktable new
mktable old

# Tuples are replaced
# 1) by explicit src-N match (src->bin+);
O='1.1 1.2 1.3 1.4 1.5 1.6 1.7'
join -t$'\t' -o "$O" -j 1 old new >rm-by-src
sort -u -o rm-by-src{,}

# 2) by implicit bin-N match (src<-bin).
sort -k4,4 -o old{,}
sort -k4,4 -o new{,}
join -t$'\t' -o "$O" -j 4 old new >rm-by-bin
sort -u -o rm-by-bin{,}

# Implicit match can be wrong, so issue a warning.
comm -23 rm-by-{bin,src} >rm-by-bin-only
if [ -s rm-by-bin-only ]; then
	echo ' *** Warning: existing src.rpm kicked by new non-matching rpm'
	cut -f3,4 <rm-by-bin-only |sort -u
fi >&2

# Implicit (src<-bin) match should be propagated to (src->bin+).
sort -u -o old{,}
sort -u -o rm-by-bin{,}
join -t$'\t' -o "$O" -j 1 old rm-by-bin >rm-by-bin+

# Replaced tuples.
sort -u rm-by-{src,bin+} >rm

# Save pairs: old src-N, their new non-matching src-F replacers
sort -k4,4 -o rm-by-bin-only{,}
# join by bin-N, output: src1-N  src2-F
join -t$'\t' -o '1.1 2.3' -j 4 rm-by-bin-only new |
	sort -u >oldsrc2newsrpm

# Guess what.  The plan is actually about moving some files around.
cd - >/dev/null
mkdir -p plan

# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-A  bin-F
cut -f1-7 <$tmpdir/new |sort -u >plan/add-src+bin
# src-N  src-EVR  src-F
cut -f1-3 <$tmpdir/new |sort -u >plan/add-src
# src-F  bin-A
cut -f3,6 <$tmpdir/new |sort -u >plan/add-srpm2arch
# bin-N  bin-EVR  bin-A  bin-F
cut -f4-7 <$tmpdir/new |sort -u >plan/add-bin

cut -f1-7 <$tmpdir/rm |sort -u >plan/rm-src+bin
cut -f1-3 <$tmpdir/rm |sort -u >plan/rm-src
cut -f3,6 <$tmpdir/rm |sort -u >plan/rm-srpm2arch
cut -f4-7 <$tmpdir/rm |sort -u >plan/rm-bin
cat <$tmpdir/oldsrc2newsrpm >plan/oldsrc2newsrpm
