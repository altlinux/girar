#!/bin/sh -efu

# Make a plan for upgrade: assuming that all new packages go
# into the repo, find out the existing packages which should
# be replaced or removed.

. gb-sh-setup
id="$1"; shift
cd "$GB_TASKS/$id"

N="%{NAME}"
VR="%{VERSION}-%{RELEASE}"
EVR="%|SERIAL?{%{SERIAL}:}|$VR"
NVR="%{NAME}-$VR"

set +f

qsrc()
{
	find "$@" -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$NVR.src.rpm\n" -p --
}

qbin()
{
	find "$@" -name '*.rpm' -not -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$NVR.%{ARCH}.rpm\t%{SOURCERPM}\n" -p --
}

. tmpdir.sh

qsrc build/*/*/srpm/ >$TMPDIR/new.src
qbin build/*/*/rpms/ >$TMPDIR/new.bin
sort -u -o $TMPDIR/new.src{,}
sort -u -o $TMPDIR/new.bin{,}

# XXX no setup yet
repo=/ALT/$GB_REPO

qsrc $repo/{i586,x86_64,noarch}/SRPMS.*/ >$TMPDIR/old.src
qbin $repo/{i586,x86_64,noarch}/RPMS.*/ >$TMPDIR/old.bin
sort -u -o $TMPDIR/old.src{,}
sort -u -o $TMPDIR/old.bin{,}

# Now what's the plan?  I guess we don't just move some files around.
# We deal with "tuples" (src,bin+).  Therefore, the consistent plan is
# to group files into such tuples, and decide how new tuples replace
# the existing tuples.
#
# Thus we have to assume that the repo is consistent: both src->bin+
# and bin->src mappings must exist for every package in the repo.  Stale
# packages cannot be handled by the plan consistently, and removing them
# is someone else's job.
#
# Tuples are represented with the following table:
#
# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-F
# -----  -------  -----  -----  -------  -----
#
# Note: the fact that both mappings mentioned above exist roughly means
# that we can join src+bin on %{SOURCERPM}.  This is how we do the table.

mktable()
{
	local x="$1"; shift
	sort -k3 -o $TMPDIR/$x.src{,}
	sort -k4 -o $TMPDIR/$x.bin{,}
	join -t$'\t' -13 -24 -o '1.1 1.2 1.3 2.1 2.2 2.3' $TMPDIR/$x.{src,bin} >$TMPDIR/$x
	sort -u -o $TMPDIR/$x{,}
}

mktable new
mktable old

# Tuples are replaced
# 1) by explicit src-N match (src->bin+);
O='1.1 1.2 1.3 1.4 1.5 1.6'
join -o "$O" -j 1 $TMPDIR/{old,new} >$TMPDIR/rm-by-src
sort -u -o $TMPDIR/rm-by-src{,}

# 2) by implicit bin-N match (src<-bin).
sort -k4,4 -o $TMPDIR/old{,}
sort -k4,4 -o $TMPDIR/new{,}
join -o "$O" -j 4 $TMPDIR/{old,new} >$TMPDIR/rm-by-bin
sort -u -o $TMPDIR/rm-by-bin{,}

# Implicit match can be wrong, so issue a warning.
comm -23 $TMPDIR/rm-by-{bin,src} >$TMPDIR/rm-by-bin-only
if [ -s $TMPDIR/rm-by-bin-only ]; then
	echo ' *** Warning: existing src.rpm kicked by new non-matching rpm'
	cut -f3,4 <$TMPDIR/rm-by-bin-only
fi >&2

# Implicit (src<-bin) match should be propagated to (src->bin+).
sort -u -o $TMPDIR/old{,}
sort -u -o $TMPDIR/rm-by-bin{,}
join -o "$O" -j 1 $TMPDIR/{old,rm-by-bin} >$TMPDIR/rm-by-bin+

# Replaced tuples.
sort -u $TMPDIR/rm-by-{src,bin+} >$TMPDIR/rm
