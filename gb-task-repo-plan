#!/bin/sh -efu

# Make a plan for upgrade: assuming that all new packages go
# into the repo, find out the existing packages which should
# be replaced or removed.

N="%{NAME}"
VR="%{VERSION}-%{RELEASE}"
EVR="%|SERIAL?{%{SERIAL}:}|$VR"
NVR="%{NAME}-$VR"
A="%{ARCH}"

set +f

qsrc()
{
	find "$@" -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$NVR.src.rpm\n" -p --
}

qbin()
{
	find "$@" -name '*.rpm' -not -name '*.src.rpm' -print0 | xargs -r0 \
		rpmquery --qf "$N\t$EVR\t$A\t$NVR.$A.rpm\t%{SOURCERPM}\n" -p --
}

. tmpdir.sh

qsrc build/*/*/srpm/ >$TMPDIR/new.src
qbin build/*/*/rpms/ >$TMPDIR/new.bin
sort -u -o $TMPDIR/new.src{,}
sort -u -o $TMPDIR/new.bin{,}

. gb-sh-repo-conf

qsrc $GB_REPO_DIR/{i586,x86_64,noarch}/SRPMS.*/ >$TMPDIR/old.src
qbin $GB_REPO_DIR/{i586,x86_64,noarch}/RPMS.*/ >$TMPDIR/old.bin
sort -u -o $TMPDIR/old.src{,}
sort -u -o $TMPDIR/old.bin{,}

# Now what's the plan?  I guess we don't just move some files around.
# We deal with "tuples" (src,bin+).  Therefore, the consistent plan is
# to group files into such tuples, and decide how new tuples replace
# the existing tuples.
#
# Thus we have to assume that the repo is consistent: both src->bin+
# and bin->src mappings must exist for every package in the repo.  Stale
# packages cannot be handled by the plan consistently, and removing them
# is someone else's job.
#
# Tuples are represented with the following table:
#
# src-N  src-EVR  src-F  bin-N  bin-EVR  bin-A  bin-F
# -----  -------  -----  -----  -------  -----  -----
#
# Note: the fact that both mappings mentioned above exist roughly means
# that we can join src+bin on %{SOURCERPM}.  This is how we do the table.

mktable()
{
	local x="$1"; shift
	sort -k3 -o $TMPDIR/$x.src{,}
	sort -k5 -o $TMPDIR/$x.bin{,}
	join -t$'\t' -13 -25 -o '1.1 1.2 1.3 2.1 2.2 2.3 2.4' $TMPDIR/$x.{src,bin} >$TMPDIR/$x
	sort -u -o $TMPDIR/$x{,}
}

mktable new
mktable old

# Tuples are replaced
# 1) by explicit src-N match (src->bin+);
O='1.1 1.2 1.3 1.4 1.5 1.6 1.7'
join -t$'\t' -o "$O" -j 1 $TMPDIR/{old,new} >$TMPDIR/rm-by-src
sort -u -o $TMPDIR/rm-by-src{,}

# 2) by implicit bin-N match (src<-bin).
sort -k4,4 -o $TMPDIR/old{,}
sort -k4,4 -o $TMPDIR/new{,}
join -t$'\t' -o "$O" -j 4 $TMPDIR/{old,new} >$TMPDIR/rm-by-bin
sort -u -o $TMPDIR/rm-by-bin{,}

# Implicit match can be wrong, so issue a warning.
comm -23 $TMPDIR/rm-by-{bin,src} >$TMPDIR/rm-by-bin-only
if [ -s $TMPDIR/rm-by-bin-only ]; then
	echo ' *** Warning: existing src.rpm kicked by new non-matching rpm'
	cut -f3,4 <$TMPDIR/rm-by-bin-only |sort -u
fi >&2

# Implicit (src<-bin) match should be propagated to (src->bin+).
sort -u -o $TMPDIR/old{,}
sort -u -o $TMPDIR/rm-by-bin{,}
join -t$'\t' -o "$O" -j 1 $TMPDIR/{old,rm-by-bin} >$TMPDIR/rm-by-bin+

# Replaced tuples.
sort -u $TMPDIR/rm-by-{src,bin+} >$TMPDIR/rm

# Guess what.  The plan is actually about moving some files around.
mkdir -p plan
cut -f1-3 <$TMPDIR/new |sort -u >plan/add-src
cut -f4-7 <$TMPDIR/new |sort -u >plan/add-bin

cut -f1-3 <$TMPDIR/rm |sort -u >plan/rm-src
cut -f4-7 <$TMPDIR/rm |sort -u >plan/rm-bin
